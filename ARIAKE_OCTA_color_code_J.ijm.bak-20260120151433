mkdir -p src/ariake_octa
cat > requirements.txt <<'TXT'
numpy
scipy
scikit-image
opencv-python
tifffile
pandas
matplotlib
networkx
sknw
shapely
TXT

cat > README.md <<'MD'
ARIAKE OCTA Python port (prototype)

Quick start:
1. Create venv and install:
   python -m venv .venv
   source .venv/bin/activate
   pip install -r requirements.txt

2. Run (example):
   python run_analysis.py --input /path/to/images --output ./results --mode both --scale-mm 6

This repo provides minimal stubs for:
- I/O (scan images, save CSV)
- Preprocessing (CLAHE, background subtraction)
- Filters (Frangi, Gabor, fusion)
- Adaptive binarization (Phansalkar-like)
- Skeleton metrics (skeletonize + graph analysis)
MD

cat > src/ariake_octa/__init__.py <<'PY'
__version__ = "0.1"
PY

cat > src/ariake_octa/cli.py <<'PY'
import argparse
from .io import scan_images, save_results_table
from .preprocess import preprocess_image
from .filters import multi_scale_frangi, gabor_filter_max, fuse_filters
from .binarize import adaptive_binarize_phansalkar
from .skeleton import compute_skeleton_metrics

def run_vd_analysis(input_dir, output_dir, params):
    # placeholder: scan and process VD pairs
    files = scan_images(input_dir, pattern="*1.tif")
    print("VD files found:", len(files))
    # implement per-file processing

def run_mnv_analysis(input_dir, output_dir, params):
    files = scan_images(input_dir, pattern="*.tif")
    print("MNV files found:", len(files))
    # implement per-file processing

def main():
    p = argparse.ArgumentParser(description="ARIAKE OCTA analysis (prototype)")
    p.add_argument("--input", required=True)
    p.add_argument("--output", required=True)
    p.add_argument("--mode", choices=["vd","mnv","both"], default="both")
    p.add_argument("--scale-mm", type=float, default=6.0)
    args = p.parse_args()
    params = {"scale_mm": args.scale_mm}
    if args.mode in ("vd","both"):
        run_vd_analysis(args.input, args.output, params)
    if args.mode in ("mnv","both"):
        run_mnv_analysis(args.input, args.output, params)

if __name__ == "__main__":
    main()
PY

cat > src/ariake_octa/io.py <<'PY'
from pathlib import Path
import fnmatch
import pandas as pd

def scan_images(folder, pattern="*.tif"):
    p = Path(folder)
    files = [str(f) for f in p.rglob(pattern)]
    files.sort()
    return files

def save_results_table(rows, outpath):
    df = pd.DataFrame(rows)
    df.to_csv(outpath, index=False)
    return outpath
PY

cat > src/ariake_octa/preprocess.py <<'PY'
import numpy as np
import cv2
from skimage import exposure
from scipy.ndimage import gaussian_filter

def preprocess_image(img, clahe_clip=3.0, background_sigma=5.0):
    # img: numpy array (H,W[,C])
    if img.ndim == 3 and img.shape[2] == 3:
        # use green channel like macro
        img = img[:,:,1]
    img = img.astype("float32")
    # CLAHE via OpenCV
    clahe = cv2.createCLAHE(clipLimit=clahe_clip, tileGridSize=(8,8))
    img8 = np.clip(img,0,255).astype("uint8")
    cl = clahe.apply(img8)
    # background subtraction
    bg = gaussian_filter(cl.astype("float32"), sigma=background_sigma)
    res = cl.astype("float32") - bg
    # normalize
    res = res - res.min()
    if res.max() > 0:
        res = res / res.max() * 255.0
    return res.astype("uint8")
PY

cat > src/ariake_octa/filters.py <<'PY'
import numpy as np
from skimage.filters import frangi
from skimage.filters import gabor_kernel
from scipy import signal

def multi_scale_frangi(img, scales=(0.8,1.0,1.2,1.5,2.0)):
    # img: 2D, uint8 or float
    imgf = img.astype("float32")/255.0
    # use skimage frangi (single-scale approximate: call with sigmas list)
    try:
        res = frangi(imgf, scale_range=(min(scales), max(scales)), scale_step=0.5)
    except Exception:
        # fallback: gaussian + sobel ridge approximation
        res = imgf
    res = (res - res.min()) / (res.max()-res.min()+1e-12)
    return (res*255).astype("uint8")

def gabor_filter_max(img, thetas=(0,30,60,90,120,150), sigma=2.0, wavelength=8.0):
    imgf = img.astype("float32")/255.0
    out = np.zeros_like(imgf)
    for theta in thetas:
        kern = np.real(gabor_kernel(frequency=1.0/wavelength, theta=np.deg2rad(theta), sigma_x=sigma, sigma_y=sigma))
        # convolution
        conv = signal.fftconvolve(imgf, kern, mode="same")
        out = np.maximum(out, conv)
    out = (out - out.min()) / (out.max()-out.min()+1e-12)
    return (out*255).astype("uint8")

def fuse_filters(filter_imgs, weights=None):
    # filter_imgs: list of numpy arrays (same shape)
    if not filter_imgs:
        raise ValueError("No filters to fuse")
    if weights is None:
        weights = [1.0/len(filter_imgs)]*len(filter_imgs)
    acc = None
    for img, w in zip(filter_imgs, weights):
        arr = img.astype("float32")
        if acc is None:
            acc = arr*w
        else:
            acc += arr*w
    acc = acc - acc.min()
    if acc.max() > 0:
        acc = acc / acc.max() * 255.0
    return acc.astype("uint8")
PY

cat > src/ariake_octa/binarize.py <<'PY'
import numpy as np
from scipy.ndimage import uniform_filter

def adaptive_binarize_phansalkar(img, radius=15, k=0.1, R=128, p=2, q=10):
    # approximate Phansalkar using local mean and std
    imgf = img.astype("float32")
    size = 2*radius+1
    mean = uniform_filter(imgf, size)
    mean_sq = uniform_filter(imgf*imgf, size)
    variance = mean_sq - mean*mean
    std = np.sqrt(np.maximum(variance, 0))
    # Phansalkar formula approximation
    Rval = R if R>0 else 128
    thresh = mean * (1 + p * np.exp(-q * mean/255.0) + k * ((std / Rval) - 1))
    mask = imgf > thresh
    return (mask.astype("uint8")*255)
PY

cat > src/ariake_octa/skeleton.py <<'PY'
import numpy as np
from skimage.morphology import skeletonize
from scipy.ndimage import distance_transform_edt

def compute_skeleton_metrics(binary_mask, pixel_size_um=1.0):
    # binary_mask: boolean or 0/255 uint8
    bw = (binary_mask > 0)
    sk = skeletonize(bw).astype("uint8")
    dist = distance_transform_edt(bw)
    # skeleton diameter stats at skeleton points
    sk_points = sk.astype(bool)
    if sk_points.sum() == 0:
        return {"skeleton_mean_um":0, "skeleton_std_um":0, "skeleton_max_um":0}
    values = dist[sk_points]
    mean = values.mean()*2*pixel_size_um
    std = values.std()*2*pixel_size_um
    mx = values.max()*2*pixel_size_um
    return {"skeleton_mean_um":mean, "skeleton_std_um":std, "skeleton_max_um":mx}
PY

cat > run_analysis.py <<'PY'
from src.ariake_octa.cli import main
if __name__ == "__main__":
    main()
PY/// Complete Integrated OCT-A Analysis Macro
/// Combines VD (Vessel Density) and MNV (Macular Neovascularization) Analysis
/// Developed by Team Yanagi (2025)
/// Mexican Top Hat Filter (https://imagej.net/ij/plugins/mexican-hat/index.html) obsolete
/// LoG filter (FeatureJ: upload... imagescience) 
/// version 2 (2025/21/1) 
/// minor revision (for past processing PC Mac M4 Pro, covert RGB to 8-bit images for VD analysis),  2/12/2025
/// Removed invalid characters from file named for Windows 18/12/2025



#@ File (label = "Input directory", style = "directory") input
#@ File (label = "Results Output directory", style = "directory") t_original_output
#@ String(label = "Analysis Type", choices = {"VD Analysis", "MNV Analysis", "Both"}) analysisType
#@ String(label = "Side (VD only)", choices = {"right", "left"}) Side
#@ int (label = "Image Width = mm") scale_mm
#@ boolean (label = "Save Pipeline Stages?") checkbox


// ===== MNV CONSTANTS =====
var MAX_DESPECKLE_ITERATIONS = 15;
var ROI_MOD_ITERATIONS = 5;
var ROI_MOD_SEARCH_RADIUS = 3;
var ROI_MOD_ANGLE_THRESHOLD = 0.5;
var FD_NUM_RINGS = 3;
var FD_ENLARGE_STEP_MM = 0.2;
var SKELETON_MAX_RETRIES = 3;
var PHANSALKAR_DESIRED_RADIUS_UM = 24;

// ===== BatchMode State Management =====
var batchModeEnabled = false;
var batchModeHidden = false;
var forceShowMode = false;

// ===== VD ANALYSIS VARIABLES =====
var vd_number_of_images = 0;
var vd_index = 0;
var sup_suffix = "1.tif";
var deep_suffix = "2.tif";

var filteredList;
var filteredsupList;
var filtereddeepList;
var FAZ_Areas_s;
var Circularity;
var Areas_s;
var Sup_Areas_s;
var Temp_Areas_s;
var Nasal_Areas_s;
var Inferior_Areas_s;
var Areas_d;
var Sup_Areas_d;
var Temp_Areas_d;
var Nasal_Areas_d;
var Inferior_Areas_d;

// ============================================================
// OCTA Advanced Analysis Functions Library
// Receives FAZ-masked images and performs advanced vessel analysis
// ============================================================

// -------------------------------
// Global Constants
// -------------------------------
var startTime = getTime();
var LIB_VERSION = "2.0";
// Frangi Scales: Extended to 4.0 for large vessels
var FRANGI_SCALES = newArray(0.8, 1.0, 1.2, 1.5, 2.0, 2.5, 3.0, 4.0);
// Filter Orientations (degrees)
var FILTER_ORIENTATIONS = newArray(0, 30, 60, 90, 120, 150);
// Gabor Filter Parameters
var GABOR_SIGMA = 2.0;
var GABOR_WAVELENGTH = 8.0;
var GABOR_GAMMA = 0.5;
var GABOR_PSI = 0;
// CLAHE Parameters
var CLAHE_BLOCKSIZE = 127;
var CLAHE_HISTOGRAM = 256;
var CLAHE_MAX_SLOPE = 3;
// Background Subtraction Gaussian Sigma
var BACKGROUND_SUBTRACTION_SIGMA = 5.0;
// Adaptive Threshold Parameters: Using Phansalkar method
var ADAPTIVE_THRESHOLD_METHOD = "Phansalkar";
var ADAPTIVE_THRESHOLD_PARAM1 = 0.1; // k value
var ADAPTIVE_THRESHOLD_PARAM2 = 0;   // R value

// -------------------------------
// Global Flags
// -------------------------------
var DO_PREPROCESSING = false;
var DEBUG = false; // Set to true to enable log

// === CONFIGURATION (論文推奨値) ===
var SCALE_PIXELS_PER_MM = 420;  // 論文標準
var THRESHOLD_SVP = 135;         // Superficial Vascular Plexus
var THRESHOLD_ICP = 110;         // Intermediate Capillary Plexus

// ===== MNV ANALYSIS VARIABLES =====
var mnv_number_of_images = 0;
var index = 0;
var cc_suffix = "4.tif"
var gaussian_sigma = 1;
var checkbox_gaussian = false;
var checkbox_seq = false;
var image_number = 0;
var ref_image_number = 0;
var mexican_hat_filter_radius = 1;
var tubeness_filter_radius = 1;

var MNV_Areas;
var vessel_Areas;
var vessel_Junctions;
var vessel_Branches;
var Corrected_vessel_diameters;
var vessel_Lengths;
var Corrected_vessel_length;
var fractal_dimensions;
var highSkewPercentage;
var end_points;
var triple_points;
var quadruple_points;
var torts;
var vessel_densities;
var junction_densities;
var branch_densities;
var vessel_diameters;
var multiple_densities;
var endpoint_densities;
var skeleton_diameter;
var skeleton_diameter_std;
var skeleton_diameter_max;
var max_mean_ratio;
var max_mean_sd;
var ID;
var mean_intensity;
var MNV_max_mean_ratio;
var standard_deviation;
var vessel_density_index;
var immature_vessel_area_index;
var CV_diameter;
var QC;

var FD_percent_R1;
var FD_percent_R2;
var FD_percent_R3;
var FD_average_area_R1;
var FD_average_area_R2;
var FD_average_area_R3;
var FD_number_R1;
var FD_number_R2;
var FD_number_R3;
var FD_number_per_length_R1;
var FD_number_per_length_R2;
var FD_number_per_length_R3;
var FD_density_R1;
var FD_density_R2;
var FD_density_R3;
var FD_ring_index_R1;
var FD_ring_index_R2;
var FD_ring_index_R3;

var FD_center;
var FD_periphery;
var euler_center;
var euler_periphery;
var vessel_length_center;
var vessel_length_periphery;
var tortuosity_center;
var tortuosity_periphery;
var trunk_eccentricity;
var angular_distribution_cv;

var center_totalLength;
var center_sumWeightedTortuosity;
var center_branchCount;

var periphery_totalLength;
var periphery_sumWeightedTortuosity;
var periphery_branchCount;
var loop_center;
var loop_periphery;


// ===== SHARED VARIABLES =====
var mainFolder;
var s_output;
var t_output;
var originalimage;
var imageWidth;
var imageHeight;
var mm_per_pixcel;
var pixel_size_um;
var phansalkar_rad;
var globalFilteredList;

// ========================================
// 毛細血管細動脈化検出
// ========================================
// マクロの最初に初期化
var saved_MNV_xCoords;
var saved_MNV_yCoords;
var saved_MNV_type;
var saved_MNV_x;
var saved_MNV_y;
var saved_MNV_width;
var saved_MNV_height;

// グローバル変数
var arteriolarization_segment_count;
var arteriolarization_total_length;
var arteriolarization_max_segment_length;
var arteriolarization_density;
var arteriolarization_connectivity_index;
var localized_diameter_variation;

// 空間分布解析用の追加変数
var diameter_center_mean;
var diameter_periphery_mean;
var diameter_center_periphery_ratio;
var diameter_radial_gradient;
var thick_vessel_center_ratio;
var thick_vessel_periphery_ratio;
var center_branch;
var periphery_branch;

// MNVサブタイプ分類用の追加変数
var vessel_density_center;
var vessel_density_periphery;
var vessel_density_ratio;
var branch_density_center;
var branch_density_periphery;
var branch_density_ratio;
var junction_density_center;
var junction_density_periphery;
var mean_diameter_center;
var mean_diameter_periphery;
var mnv_subtype;
var subtype_confidence;
var stability_score;
var complexity_score;
var maturity_index;
var patternClassification;
var totalScore;
var confidence;


// グローバル変数に追加
var skeleton_mean, skeleton_std, skeleton_min, skeleton_max;
var global_skewThreshold; 

// ===== INITIALIZATION =====
run("Close All");
run("Colors...", "foreground=white background=black selection=white");
print("\\Clear");
safeRoiClose();
    regStartTime = getTime();
// ===== MAIN EXECUTION =====
if (analysisType == "VD Analysis" || analysisType == "Both") {
    print("========================================");
    print("=== Starting VD Analysis ===");
    print("========================================");
    executeVDAnalysis();
}

if (analysisType == "MNV Analysis" || analysisType == "Both") {
    print("========================================");
    print("=== Starting MNV Analysis ===");
    print("========================================");
    executeMNVAnalysis();
}

print("========================================");
print("=== All Analysis Complete ===");
print("========================================");


safeRoiClose();
endTime = getTime();
endDateTime = getDateTimeString();
elapsedTime = (endTime - startTime) / 1000; // 秒単位

run("Close All");
print("\n=================================================");
print("ARIAKE MNV analysis completed successfully!");
print("End time: " + endDateTime);
print("Total processing time: " + d2s(elapsedTime, 2) + " seconds");
print("Version: 2.1");
print("=================================================");

// ログをファイルに保存
saveLogToFile();

// =====================================================================
// VD ANALYSIS FUNCTIONS
// =====================================================================

function executeVDAnalysis() {
    mainFolder = File.getName(input);
    t_output = t_original_output + File.separator + mainFolder + "_VD";
    if (!File.exists(t_output)) {
        File.makeDirectory(t_output);
    }
    s_output = t_output + File.separator;
    if (!File.exists(s_output)) {
        File.makeDirectory(s_output);
    }
    
    vd_number_of_images = 0;
    vd_index = 0;
    
    countVDFiles(input, sup_suffix);
    var size = vd_number_of_images;
    
    if (size == 0) {
        print("No VD files found (suffix: " + sup_suffix + ")");
        return;
    }
    
    print("Found " + size + " VD image pairs");
    
    filteredList = newArray(size);
    filteredsupList = newArray(size);
    filtereddeepList = newArray(size);
    FAZ_Areas_s = newArray(size);
    Circularity = newArray(size);
    Areas_s = newArray(size);
    Sup_Areas_s = newArray(size);
    Temp_Areas_s = newArray(size);
    Nasal_Areas_s = newArray(size);
    Inferior_Areas_s = newArray(size);
    Areas_d = newArray(size);
    Sup_Areas_d = newArray(size);
    Temp_Areas_d = newArray(size);
    Nasal_Areas_d = newArray(size);
    Inferior_Areas_d = newArray(size);
    
    processVDFolder(input);
    createVDTable();
}

function countVDFiles(folder, suffix) {
    list = getFileList(folder);
    for (i = 0; i < list.length; i++) {
        if (endsWith(list[i], "/")) {
            countVDFiles(folder + File.separator + list[i], suffix);
        } else if (endsWith(list[i].toLowerCase(), suffix.toLowerCase())) {
            vd_number_of_images++;
        }
    }
}

function processVDFolder(input) {
    list = getFileList(input);
    list = Array.sort(list);
    
    var tempSupList = newArray();
    var tempDeepList = newArray();
    
    for (i = 0; i < list.length; i++) {
        fullPath = input + File.separator + list[i];
        if (File.isDirectory(fullPath)) {
            processVDFolder(fullPath);
        } else if (endsWith(list[i], sup_suffix)) {
            tempSupList = Array.concat(tempSupList, list[i]);
        } else if (endsWith(list[i], deep_suffix)) {
            tempDeepList = Array.concat(tempDeepList, list[i]);
        }
    }
    
    for (i = 0; i < tempSupList.length; i++) {
        sup_file = tempSupList[i];
        deep_file = tempDeepList[i];
        patient_id = replace(sup_file, sup_suffix, "");
        
        filteredList[vd_index] = patient_id;
        filteredsupList[vd_index] = sup_file;
        filtereddeepList[vd_index] = deep_file;
        
        print("Processing VD pair " + (vd_index + 1) + "/" + vd_number_of_images + ": " + patient_id);
        processVDFile(input, sup_file, deep_file);
        vd_index++;
    }
    
    safeRoiClose();
}

function processVDFile(input, sup_file, deep_file) {
    safeRoiClose();
    id=0;
    idcopy=0;
    iddeep=0;
    idcopy2=0;
    
    var deepPath = input + File.separator + deep_file;
    if (!File.exists(deepPath)) {
        print("Error: deep file not found");
        return;
    }
	
	var supPath = input + File.separator + sup_file;
    if (!File.exists(supPath)) {
        print("Error: sup file not found");
        close(iddeep);
        return;
    }

	open(supPath);
	id = getImageID();
    run("8-bit");
    imageWidth = getWidth();
    imageHeight = getHeight();
    run("Duplicate...", "title=copy_FAZ_Skeleton");
    idcopy = getImageID();
     
    DO_PREPROCESSING = false;
    DEBUG = false;
    pipelineType = "High Precision";

    analyzeVesselsAdvanced("copy_FAZ_Skeleton", pipelineType);   
    
    idcopy2 = getImageID();
 	if (isOpen(id)) close(id);
	if (isOpen(idcopy)) close(idcopy);

	open(deepPath);
    iddeep = getImageID();
    run("8-bit");
    run("Size...", "width=" + imageWidth + " height=" + imageHeight + " constrain average interpolation=Bilinear");
    
    imageCalculator("Add create", idcopy2, iddeep); // 直接加算合成し新規画像生成
	result_id = getImageID();
	if (isOpen(iddeep)) close(iddeep);  

    if (isOpen("binary_result")) {
    selectWindow("binary_result");
    run("Close");
    }
    
    selectImage(result_id);
    run("Size...", "width=800 height=800 constrain average interpolation=Bilinear");
    run("Bandpass Filter...", "filter_large=1024 filter_small=3.5 suppress=None tolerance=5 process");
    run("Auto Threshold", "method=Li white");
    setOption("BlackBackground", true);
    run("Skeletonize");

	run("Options...", "iterations=8 count=1 black");
	run("Close-");

    run("Size...", "width=" + imageWidth + " height=" + imageHeight + " constrain average interpolation=Bilinear");
    setThreshold(50, 255);
    
    safeRoiClose();
    run("Analyze Particles...", "size=0-1000 circularity=0.0-1.0 show=[Nothing] exclude clear add");
    
    n = roiManager('count');
    for (ind = 0; ind < n; ind++) {
        roiManager('select', ind);
        setColor(0, 0, 0);
        run("Fill", "slice");
    }
	run("Remove Overlay");
	safeRoiClose();
	
    centerX = imageWidth / 2;
    centerY = imageHeight / 2;
	setTool(3);
	v = getPixel(centerX, centerY);
	if (v != 0) {
    // 周囲を探索して黒ピクセルを探す
    found = 0;
    for (dx=-15; dx<=15 && !found; dx++)
        for (dy=-15; dy<=15 && !found; dy++)
            if (getPixel(centerX+dx, centerY+dy) == 0) {
                doWand(centerX+dx, centerY+dy);
                found = 1;
            }
	}
	else {
    doWand(centerX, centerY);
	}

    expandROI();
    safeRoiClose();
    roiManager("Add");
  
    selectImage(result_id);
    roiManager("Select", 0);
    getSelectionBounds(x_box, y_box, w_box, h_box);
    xc_pixel = x_box + w_box / 2;
    yc_pixel = y_box + h_box / 2;
    
    run("Set Scale...", "distance=" + imageWidth + " known=" + scale_mm + " unit=mm");
    run("Set Measurements...", "area shape redirect=None decimal=1");
    List.setMeasurements;
    
    FAZ = List.getValue("Area");
    Circ = List.getValue("Circ.");
    
    xc = xc_pixel;
    yc = yc_pixel;
    
    r = imageWidth / 2;
    makeOval(xc - r, yc - r, r * 2, r * 2);
    roiManager("Add");
    r_inner = r / 2;
    makeOval(xc - r_inner, yc - r_inner, r_inner * 2, r_inner * 2);
    roiManager("Add");
    roiManager("Select", newArray(1, 2));
    roiManager("XOR");
    roiManager("Add");
    
    xbearing = xc - imageWidth / 2;
    ybearing = yc - imageHeight / 2;
    diag = imageWidth / 2 * sqrt(2);
    
    makeRotatedRectangle(imageWidth/4+xbearing, -imageWidth/4+ybearing, imageWidth*3/4+xbearing, imageWidth/4+ybearing, diag);
    roiManager("Add");
    roiManager("Select", newArray(3, 4));
    roiManager("and");
    roiManager("Add");
    
    makeRotatedRectangle(-imageWidth/4+xbearing, imageWidth/4+ybearing, imageWidth/4+xbearing, imageWidth*3/4+ybearing, diag);
    roiManager("Add");
    roiManager("Select", newArray(3, 6));
    roiManager("and");
    roiManager("Add");
    
    makeRotatedRectangle(imageWidth*3/4+xbearing, imageWidth/4+ybearing, imageWidth*5/4+xbearing, imageWidth*3/4+ybearing, diag);
    roiManager("Add");
    roiManager("Select", newArray(3, 8));
    roiManager("and");
    roiManager("Add");
    
    makeRotatedRectangle(imageWidth/4+xbearing, imageWidth*3/4+ybearing, imageWidth*3/4+xbearing, imageWidth*5/4+ybearing, diag);
    roiManager("Add");
    roiManager("Select", newArray(3, 10));
    roiManager("and");
    roiManager("Add");
    roiManager("Select", newArray(1, 2, 4, 6, 8, 10));
    roiManager("delete");
    
    FAZ_Areas_s[vd_index] = FAZ;
    Circularity[vd_index] = Circ;

    var s_results = processPlexus(input, sup_file, "superficial");
    Areas_s[vd_index] = s_results[0];
    Sup_Areas_s[vd_index] = s_results[1];
    Inferior_Areas_s[vd_index] = s_results[2];
    Temp_Areas_s[vd_index] = s_results[3];
    Nasal_Areas_s[vd_index] = s_results[4];
    
    var d_results = processPlexus(input, deep_file, "deep");
    Areas_d[vd_index] = d_results[0];
    Sup_Areas_d[vd_index] = d_results[1];
    Inferior_Areas_d[vd_index] = d_results[2];
    Temp_Areas_d[vd_index] = d_results[3];
    Nasal_Areas_d[vd_index] = d_results[4];
    
    safeRoiClose();
	
	if (isOpen("copy_FAZ_Skeleton")) {
    selectWindow("copy_FAZ_Skeleton");
    run("Close");
    } 


}

function processPlexus(inputPath, file, label) {
    var fullPath = inputPath + File.separator + file;
    if (!File.exists(fullPath)) {
        print("Warning: file not found - " + file);
        return newArray(-1, -1, -1, -1, -1);
    }
    
    open(fullPath);

    saveStageVD(t_output, file, label + "_original");
    img_process_measurement();
    
    run("Set Measurements...", "area_fraction redirect=None decimal=1");
    
    PAREA = measureAreaFraction(1);
    UPAREA = measureAreaFraction(2);
    LPAREA = measureAreaFraction(3);
    RPAREA = measureAreaFraction(4);
    BPAREA = measureAreaFraction(5);
    
    if (Side == "right") {
        TPAREA = LPAREA;
        NPAREA = RPAREA;
    } else {
        TPAREA = RPAREA;
        NPAREA = LPAREA;
    }
    
    roiManager("show all without labels");
    saveStageVD(t_output, file, label + "_");
    close();
    
    return newArray(PAREA, UPAREA, BPAREA, TPAREA, NPAREA);
}

function img_process_measurement() {
    // 開いている画像のファイル名から層タイプを自動判定
    filename = getTitle();
    layerType = getLayerType(filename);
    originalTitle = getTitle();
    print("処理中: " + filename + " [" + layerType + "]");
    
        roiManager("Select", 0);
        // Clear Outsideの代わりにマスク処理
        run("Create Mask");
        imageCalculator("AND create", getTitle(), "Mask");
        selectWindow("Mask");
        close();
        selectWindow(getTitle());
        rename("masked");
        run("Invert");
        // 元の画像とマスクのAND演算
        selectWindow(filename);
        imageCalculator("AND create", originalTitle, "masked");
        resultTitle = getTitle();
                // クリーンアップ
        selectWindow("masked");
        close();
        selectWindow(filename);
        close();
        
        // 結果をアクティブに
        selectWindow(resultTitle);
        rename(filename);
 
	 imageName = getTitle();
     
    DO_PREPROCESSING = false;
    DEBUG = false;
    pipelineType = "High Precision";
    
    analyzeVesselsAdvanced(imageName, pipelineType);        

    checkImageQuality();
}
// ============================================================
// Main Analysis Function
// ============================================================
function analyzeVesselsAdvanced(imageName, pipelineType) {
   
    imgWidth = 0;
    imgHeight = 0;
    selectWindow(imageName);
    imgWidth = getWidth();
    imgHeight = getHeight();
       
    // Step 1: Preprocessing
    if (DO_PREPROCESSING) {
        print(">> Step 1: Preprocessing");
        preprocessed = preprocessImage(imageName);
    } else {
        print(">> Step 1: Preprocessing SKIPPED");
        selectWindow(imageName);
        run("Duplicate...", "title=input_copy");
        preprocessed = "input_copy";
        libRegisterTemp(preprocessed);
    }
    
    print(">> Step 2: Filter Processing");
    
    // Frangi Filter
    frangi = applyMultiScaleFrangiSimple(preprocessed);
    if (DEBUG) {
        selectWindow(frangi);
        rename("!!! Frangi Result (Verify Center is Bright) !!!");
        print(">>> DEBUG: Check Frangi filter result (are vessel centers bright?)");
        waitForUser("Frangi Result Check", "Please verify Frangi filter result.\nClick OK to proceed to next filter.");
        rename(frangi);
    }

    // Gabor Filter
    gabor = applyGaborFilterSimple(preprocessed);
    if (DEBUG) {
        selectWindow(gabor);
        rename("!!! Gabor Result (Verify Vessels are Bright) !!!");
        print(">>> DEBUG: Check Gabor filter result");
        waitForUser("Gabor Result Check", "Please verify Gabor filter result.\nClick OK to proceed to next filter.");
        rename(gabor);
    }
    // Apply Filter Pipeline (Fusion)
    enhanced = applyFilterPipeline(preprocessed, pipelineType);
    // User verification for FUSED result
    if (DEBUG) {
        selectWindow(enhanced);
        rename("!!! FUSED RESULT (Check Capillaries) !!!");
        print(">>> DEBUG: Check fused filter result and click OK");
        waitForUser("Fused Filter Result Check", "Please verify capillary enhancement.\nClick OK to proceed to binarization.");
        rename(enhanced);
    }
    
    print(">> Step 3: Adaptive Binarization");
    binary = binarizeAdaptive(enhanced);
    if (DEBUG) {
        selectWindow(binary);
        rename("!!! BINARY RESULT (Check Thickness) !!!");
        print(">>> DEBUG: Check binary result and click OK");
        waitForUser("Binary Result Check", "Please verify binary result.\nClick OK to proceed to post-processing.");
        rename(binary);
    }
        
    // Close all images except the binary result
    if (DEBUG) print(">> Cleaning up intermediate images...");
    list = getList("image.titles");
    for (i = 0; i < list.length; i++) {
        if (list[i] != binary) {
            selectWindow(list[i]);
            close();
        }
    }
    if (DEBUG) print(">> Only binary image remains open: " + binary);
}

// ============================================================
// 1. Preprocessing (with skip option)
// ============================================================
function preprocessImage(imageName) {
    selectWindow(imageName);
    run("Duplicate...", "title=preprocessed_temp");
    libRegisterTemp("preprocessed_temp");
    
    if (bitDepth() == 24) {
        print("  - RGB image detected: Extracting green channel");
        run("Split Channels");
        if (isOpen(imageName + " (green)")) {
            selectWindow(imageName + " (green)");
            rename("preprocessed_temp");
            if (isOpen(imageName + " (red)")) close(imageName + " (red)");
            if (isOpen(imageName + " (blue)")) close(imageName + " (blue)");
        } else {
            selectWindow("preprocessed_temp");
            run("8-bit");
        }
    }
    
    print("  - Applying CLAHE");
    selectWindow("preprocessed_temp");
    run("Enhance Local Contrast (CLAHE)",
        "blocksize=" + CLAHE_BLOCKSIZE +
        " histogram=" + CLAHE_HISTOGRAM +
        " maximum=" + CLAHE_MAX_SLOPE +
        " mask=*None* fast_(less_accurate)");
    
    print("  - Background Subtraction (Sigma=" + BACKGROUND_SUBTRACTION_SIGMA + ")");
    selectWindow("preprocessed_temp");
    run("Duplicate...", "title=background_temp");
    libRegisterTemp("background_temp");
    selectWindow("background_temp");
    run("Gaussian Blur...", "sigma=" + BACKGROUND_SUBTRACTION_SIGMA);
    
    imageCalculator("Subtract create", "preprocessed_temp", "background_temp");
    rename("preprocessed_final");
    libRegisterTemp("preprocessed_final");
    close("preprocessed_temp");
    close("background_temp");
    
    selectWindow("preprocessed_final");
    run("Enhance Contrast", "saturated=1 normalize");
    
    print("  - Preprocessing Complete");
    return "preprocessed_final";
}

// ============================================================
// 2. Filter Pipeline
// ============================================================
function applyFilterPipeline(imageName, pipelineType) {
    // Frangi and Gabor are already executed in main function
    if (pipelineType == "High Precision" || pipelineType == "Balanced") {
        if (DEBUG) print("  - Fusion Pipeline (Frangi 40% / Gabor 40%)");
        
        filters = newArray("frangi_result", "gabor_result");
        weights = newArray(0.4, 0.4);
        fusedResult = fuseFiltersSimple(filters, weights);
        
        return fusedResult;
        
    } else if (pipelineType == "Fast") {
        print("  - Fast Pipeline (Frangi only)");
        if (isOpen("gabor_result")) close("gabor_result");
        return "frangi_result";
        
    } else {
        print("  - Traditional Pipeline (Gaussian Blur)");
        if (isOpen("frangi_result")) close("frangi_result");
        if (isOpen("gabor_result")) close("gabor_result");
        
        selectWindow(imageName);
        run("Duplicate...", "title=simple_filtered");
        libRegisterTemp("simple_filtered");
        selectWindow("simple_filtered");
        run("Gaussian Blur...", "sigma=1.5");
        return "simple_filtered";
    }
}

// ============================================================
// 3. Multi-Scale Frangi Filter
// ============================================================
function applyMultiScaleFrangiSimple(imageName) {
    selectWindow(imageName);
    run("8-bit");
    w = getWidth();
    h = getHeight();
    frangiResultName = "frangi_max_temp";
    newImage(frangiResultName, "32-bit black", w, h, 1);
    libRegisterTemp(frangiResultName);
    
    useFeatureJ = false;
    firstScale = true;
    
    for (i = 0; i < FRANGI_SCALES.length; i++) {
        sigma = FRANGI_SCALES[i];
        
        selectWindow(imageName);
        tempName = "fscale_" + i;
        run("Duplicate...", "title=" + tempName);
        libRegisterTemp(tempName);
        
        selectWindow(tempName);
        
        if (firstScale) {
            origName = tempName;
            run("FeatureJ Hessian", "largest absolute smoothing=" + sigma);
            
            allWindows = getList("image.titles");
            resultFound = false;
            
            for (j = 0; j < allWindows.length; j++) {
                winName = allWindows[j];
                if (indexOf(winName, "Hessian") >= 0 || indexOf(winName, "eigenvalue") >= 0) {
                    selectWindow(winName);
                    run("Abs");
                    run("Enhance Contrast", "saturated=1");
                    resultName = tempName + "_result";
                    rename(resultName);
                    libRegisterTemp(resultName);
                    resultFound = true;
                    useFeatureJ = true;
                    break;
                }
            }
            
            if (resultFound) {
                if (DEBUG) print("  FeatureJ detected: Using Hessian eigenvalue analysis (sigma=" + sigma + ")");
                if (isOpen(origName)) close(origName);
                tempName = tempName + "_result";
            } else {
                print("  WARNING: FeatureJ not found. Using ridge detection (sigma=" + sigma + ")");
                selectWindow(tempName);
                applyRidgeDetection(tempName, sigma);
            }
            
            firstScale = false;
            
        } else {
            if (useFeatureJ) {
                origName = tempName;
                run("FeatureJ Hessian", "largest absolute smoothing=" + sigma);
                
                allWindows = getList("image.titles");
                resultFound = false;
                
                for (j = 0; j < allWindows.length; j++) {
                        winName = allWindows[j];
                    if (indexOf(winName, "Hessian") >= 0 || indexOf(winName, "eigenvalue") >= 0) {
                        selectWindow(winName);
                        run("Abs");
                        resultName = tempName + "_result";
                        rename(resultName);
                        libRegisterTemp(resultName);
                        resultFound = true;
                        break;
                    }
                }
                
                if (resultFound) {
                    if (isOpen(origName)) close(origName);
                    tempName = tempName + "_result";
                } else {
                    selectWindow(tempName);
                    applyRidgeDetection(tempName, sigma);
                }
            } else {
                selectWindow(tempName);
                applyRidgeDetection(tempName, sigma);
            }
        }
        
        if (isOpen(tempName)) {
            imageCalculator("Max", frangiResultName, tempName);
            close(tempName);
        }
    }
    
    selectWindow(frangiResultName);
       
    // Keep 32-bit values to avoid saturation during fusion
    run("32-bit");
    rename("frangi_result");
    libRegisterTemp("frangi_result");
    
    return "frangi_result";
}

function applyRidgeDetection(imageName, sigma) {
    selectWindow(imageName);
    run("Gaussian Blur...", "sigma=" + sigma);
    run("Find Edges");
    run("Invert");
    run("Gaussian Blur...", "sigma=" + (sigma * 0.5));
}

// ============================================================
// 4. Gabor Filter
// ============================================================
function applyGaborFilterSimple(imageName) {
    selectWindow(imageName);
    run("8-bit");
    w = getWidth();
    h = getHeight();
    gaborResultName = "gabor_max_temp";
    newImage(gaborResultName, "32-bit black", w, h, 1);
    libRegisterTemp(gaborResultName);
    
    for (i = 0; i < FILTER_ORIENTATIONS.length; i++) {
        theta = FILTER_ORIENTATIONS[i];
        
        selectWindow(imageName);
        tempName = "gscale_" + i;
        run("Duplicate...", "title=" + tempName);
        libRegisterTemp(tempName);
        
        applyGaborKernel(tempName, GABOR_SIGMA, GABOR_WAVELENGTH, theta, GABOR_GAMMA, GABOR_PSI);
        
        imageCalculator("Max", gaborResultName, tempName);
        close(tempName);
    }
    
    selectWindow(gaborResultName);
    rename("gabor_result");
    libRegisterTemp("gabor_result");
    
    return "gabor_result";
}

function applyGaborKernel(imageName, sigma, lambda, theta, gamma, psi) {
    selectWindow(imageName);
    
    kernelSize = round(sigma * 6);
    if (kernelSize % 2 == 0) kernelSize++;
    if (kernelSize < 5) kernelSize = 5;
    
    center = floor(kernelSize / 2);
    thetaRad = theta * PI / 180;
    
    kernel = newArray(kernelSize * kernelSize);
    maxVal = 0;
    
    for (y = 0; y < kernelSize; y++) {
        for (x = 0; x < kernelSize; x++) {
            xc = x - center;
            yc = y - center;
            
            xPrime = xc * cos(thetaRad) + yc * sin(thetaRad);
            yPrime = -xc * sin(thetaRad) + yc * cos(thetaRad);
            
            gaussian = exp(-(xPrime * xPrime + gamma * gamma * yPrime * yPrime) / (2 * sigma * sigma));
            sinusoid = cos(2 * PI * xPrime / lambda + psi);
            
            value = gaussian * sinusoid;
            kernel[y * kernelSize + x] = value;
            
            if (abs(value) > maxVal) maxVal = abs(value);
        }
    }
    
    // Normalize kernel
    for (i = 0; i < kernel.length; i++) {
        kernel[i] = kernel[i] / maxVal;
    }
    
    kernelStr = arrayToConvolveString(kernel, kernelSize);
    selectWindow(imageName);
    run("Convolve...", "text1=[" + kernelStr + "] normalize");
    run("Abs");
}

// ============================================================
// 5. Filter Fusion
// ============================================================
function fuseFiltersSimple(filterNames, weights) {
    if (filterNames.length == 0) {
        print("ERROR: Filter results are empty");
        return "";
    }
    
    firstValid = -1;
    for (i = 0; i < filterNames.length; i++) {
        if (isOpen(filterNames[i])) {
            firstValid = i;
            break;
        }
    }
    
    if (firstValid < 0) {
        print("ERROR: No valid filter results");
        return "";
    }
    
    fusedName = "fused_temp";
    selectWindow(filterNames[firstValid]);
    run("Duplicate...", "title=" + fusedName);
    libRegisterTemp(fusedName);
    run("32-bit"); // Ensure 32-bit calculation
    run("Multiply...", "value=" + weights[firstValid]);
    
    for (i = firstValid + 1; i < filterNames.length; i++) {
        if (!isOpen(filterNames[i])) {
            print("WARNING: " + filterNames[i] + " not found. Skipping");
            continue;
        }
        
        tempName = "fuse_" + i;
        selectWindow(filterNames[i]);
        run("Duplicate...", "title=" + tempName);
        libRegisterTemp(tempName);
        run("32-bit");
        run("Multiply...", "value=" + weights[i]);
        
        imageCalculator("Add", fusedName, tempName);
        close(tempName);
    }
    
    // Close original filter result windows
    for (i = 0; i < filterNames.length; i++) {
        if (isOpen(filterNames[i])) close(filterNames[i]);
    }
    
    selectWindow(fusedName);
    // Final normalization after fusion
    run("Enhance Contrast", "saturated=1 normalize");
    run("8-bit");
    rename("fused_result");
    libRegisterTemp("fused_result");
    
    if (DEBUG) print("  Filter fusion complete: fused_result");
    return "fused_result";
}

// ============================================================
// 6. Adaptive Binarization (Phansalkar method)
// ============================================================
function binarizeAdaptive(imageName) {
    selectWindow(imageName);
    w = getWidth();
    h = getHeight();
    
    minDim = minOf(w, h);
    radius = round(minDim * 0.03);
    if (radius < 10) radius = 10;
    if (radius > 40) radius = 40;
    
    if (DEBUG) print("  - Adaptive Binarization (" + ADAPTIVE_THRESHOLD_METHOD + " method, radius=" + radius + ", k=" + ADAPTIVE_THRESHOLD_PARAM1 + ", R=" + ADAPTIVE_THRESHOLD_PARAM2 + ")");
    
    run("Duplicate...", "title=binary_result");
    libRegisterTemp("binary_result");
    selectWindow("binary_result");
    run("8-bit");
    run("Grays");
    
    run("Auto Local Threshold",
        "method=" + ADAPTIVE_THRESHOLD_METHOD +
        " radius=" + radius +
        " parameter_1=" + ADAPTIVE_THRESHOLD_PARAM1 +
        " parameter_2=" + ADAPTIVE_THRESHOLD_PARAM2 +
        " white");
    
    run("Convert to Mask");
    
    // 【追加】中央マスク領域（約0.1mm）の平均輝度をチェック
    centerX = w / 2;
    centerY = h / 2;
    // 0.1mmをピクセルに変換（約10pixel）
    maskRadius = 10;
    
    makeOval(centerX - maskRadius, centerY - maskRadius, maskRadius * 2, maskRadius * 2);
    getRawStatistics(nPixels, meanCenter);
    run("Select None");
    
    if (DEBUG) print("    Center mask region mean: " + d2s(meanCenter, 1));
    
    // 中央が白い（>128）なら反転が必要
    if (meanCenter > 128) {
        run("Invert");
        if (DEBUG) print("    -> INVERTED (center was white: " + d2s(meanCenter, 1) + ")");
    } else {
        if (DEBUG) print("    -> NO INVERT needed (center is black: " + d2s(meanCenter, 1) + ")");
    }
    
    // 最終結果の統計
    getRawStatistics(nPixels, meanAfter);
    whiteFraction = meanAfter / 255;
    if (DEBUG) print("    Final white%=" + d2s(whiteFraction*100,1));
    
    return "binary_result";
}

// -------------------------------
// Temporary Window Management
// -------------------------------
var libTempWindows = newArray();

function libRegisterTemp(title) {
    if (title == "") return;
    // Check for duplicates
    for (i = 0; i < libTempWindows.length; i++) {
        if (libTempWindows[i] == title) return;
    }
    libTempWindows = Array.concat(libTempWindows, newArray(title));
}

// -------------------------------
// Helper Functions
// -------------------------------
function arrayToConvolveString(array, size) {
    str = "";
    for (y = 0; y < size; y++) {
        for (x = 0; x < size; x++) {
            val = array[y * size + x];
            str += d2s(val, 6);
            if (x < size - 1) str += " ";
        }
        if (y < size - 1) str += "\n";
    }
    return str;
}


// ==================================================
// 品質管理関数
// ==================================================

function checkImageQuality() {
    // 画像の明るさ分布をチェック
    getRawStatistics(nPixels, mean, min, max, std);
    
    // 異常検出
    if (mean < 5) {
        print("警告: 画像が暗すぎます (mean=" + mean + ")");
    }
    if (std < 10) {
        print("警告: コントラストが低い可能性 (SD=" + std + ")");
    }
    
    // 血管ピクセル率の妥当性チェック
	run("Set Measurements...", "area_fraction");
	List.setMeasurements;
	vd = List.getValue("%Area");
    
    if (vd < 5 || vd > 80) {
        print("警告: 血管密度が異常範囲 (" + vd + "%)");
    }
}

function getLayerType(filename) {
    if (endsWith(filename, sup_suffix)) {
        return "SVP";
    } else if (endsWith(filename, deep_suffix)) {
        return "ICP";
    }
    
    // 予備的な判定（ファイル名に層名が含まれる場合）
    lowerFilename = toLowerCase(filename);
    if (indexOf(lowerFilename, "svp") >= 0 || indexOf(lowerFilename, "superficial") >= 0) {
        return "SVP";
    } else if (indexOf(lowerFilename, "icp") >= 0 || indexOf(lowerFilename, "intermediate") >= 0) {
        return "ICP";
    }
    
    return "UNKNOWN";
}

function measureAreaFraction(roiIndex) {
    roiManager("Select", roiIndex);
    List.setMeasurements;
    return List.getValue("%Area");
}

function saveStageVD(t_output, file, name_string) {
    if (checkbox) {
        run("Duplicate...", "title=duplicate.jpg ignore");
        run("RGB Color");
        selectWindow("duplicate.jpg");
        
        roiManager("show all without labels");
        setForegroundColor(255, 255, 0);
        roiManager("draw");
        run("Set Scale...", "distance=" + getWidth() + " known=" + scale_mm + " unit=mm");
        run("Scale Bar...", "width=1.0 height=0.2 color=Yellow horizontal bold overlay");
        saveAs("jpg", t_output + File.separator + name_string + file + ".jpg");
        run("Close");
    }
}

function createVDTable() {
    table_name = "Results-VD";
    Table.create(table_name);
    Table.setColumn("Patient ID", filteredList);
    Table.setColumn("Superficial Image ID", filteredsupList);
    Table.setColumn("Deep Image ID", filtereddeepList);
    Table.setColumn("FAZ (mm^2)", FAZ_Areas_s);
    Table.setColumn("Circularity", Circularity);
    Table.setColumn("Superficial", Areas_s);
    Table.setColumn("Superior Area (Superficial)", Sup_Areas_s);
    Table.setColumn("Temporal Area (Superficial)", Temp_Areas_s);
    Table.setColumn("Nasal Area (Superficial)", Nasal_Areas_s);
    Table.setColumn("Inferior Area (Superficial)", Inferior_Areas_s);
    Table.setColumn("Deep", Areas_d);
    Table.setColumn("Superior Area (Deep)", Sup_Areas_d);
    Table.setColumn("Temporal Area (Deep)", Temp_Areas_d);
    Table.setColumn("Nasal Area (Deep)", Nasal_Areas_d);
    Table.setColumn("Inferior Area (Deep)", Inferior_Areas_d);
    
    Res_out = t_output + File.separator + table_name + ".csv";
    saveAs("Results", Res_out);
    print("VD results saved: " + Res_out);
      
    csvWindow = "Results-VD.csv";
    if (isOpen(csvWindow)) {
        selectWindow(csvWindow);
        run("Close");
    }
    
}

// =====================================================================
// MNV ANALYSIS FUNCTIONS
// =====================================================================

function executeMNVAnalysis() {
    // mnv_suffixを自動判定
	mnv_suffix = determineMNVSuffix(input);
	if (DEBUG) print("Selected MNV suffix: " + mnv_suffix);mainFolder = File.getName(input);
	//
    t_output = t_original_output + File.separator + mainFolder + "_MNV";
    if (!File.exists(t_output)) {
        File.makeDirectory(t_output);
    }
    s_output = t_output + File.separator;
    if (!File.exists(s_output)) {
        File.makeDirectory(s_output);
    }
    
    mnv_number_of_images = 0;
    index = 0;
    image_number = 0;
    ref_image_number = 0;
    
    countFilesInFolder(input, mnv_suffix);
    
    size = mnv_number_of_images;
    if (size == 0) {
        print("No MNV files found (suffix: " + mnv_suffix + ")");
        return;
    }
    
    print("Found " + size + " MNV images");
    initializeArrays(size);
    processFolder(input);
    createMeasurementsTable();
    saveProcessingParameters();
}

// ===== mnv_suffix自動判定ロジック =====
function determineMNVSuffix(folder) {
    // まず、MNVのみを解析するか確認
    Dialog.create("Analysis Mode Selection");
    Dialog.addMessage("Do you want to analyze only MNV images?");
    Dialog.addChoice("Analysis mode:", newArray("No - Use standard logic", "Yes - Analyze only MNV"), "No - Use standard logic");
    Dialog.show();
    
    analyzeOnlyMNV = Dialog.getChoice();
    
    // "Yes"が選択された場合、全ファイルの拡張子を判定
    if (analyzeOnlyMNV == "Yes - Analyze only MNV") {
        list = getFileList(folder);
        count_tif = 0;
        count_png = 0;
        count_jpg = 0;
        
        for (i = 0; i < list.length; i++) {
            if (endsWith(list[i], ".tif") || endsWith(list[i], ".tiff")) {
                count_tif++;
            } else if (endsWith(list[i], ".png")) {
                count_png++;
            } else if (endsWith(list[i], ".jpg") || endsWith(list[i], ".jpeg")) {
                count_jpg++;
            }
        }
        
        print("MNV-only mode - File count:");
        print("  .tif: " + count_tif);
        print("  .png: " + count_png);
        print("  .jpg: " + count_jpg);
        
        // 最も多い拡張子を返す
        if (count_tif >= count_png && count_tif >= count_jpg && count_tif > 0) {
            print("Decision: Using '.tif' (MNV-only mode)");
            return ".tif";
        } else if (count_png >= count_jpg && count_png > 0) {
            print("Decision: Using '.png' (MNV-only mode)");
            return ".png";
        } else if (count_jpg > 0) {
            print("Decision: Using '.jpg' (MNV-only mode)");
            return ".jpg";
        } else {
            print("ERROR: No .tif, .png, or .jpg files found!");
            exit("No image files found for MNV analysis.");
        }
    }
    
    // "No"が選択された場合、既存のロジックを実行
    list = getFileList(folder);
    count_3tif = 0;
    count_4tif = 0;
    count_other_tif = 0;
    
    for (i = 0; i < list.length; i++) {
        if (endsWith(list[i], "3.tif")) {
            count_3tif++;
        } else if (endsWith(list[i], "4.tif")) {
            count_4tif++;
        } else if (endsWith(list[i], ".tif")) {
            count_other_tif++;
        }
    }
    
    print("File count check:");
    print("  3.tif: " + count_3tif);
    print("  4.tif: " + count_4tif);
    print("  other .tif: " + count_other_tif);
    
    // 3.tifと4.tifが同数で組になっている場合
    if (count_3tif > 0 && count_4tif > 0 && count_3tif == count_4tif) {
        // 他のtifファイルも存在する場合は確認
        if (count_other_tif > 0) {
            Dialog.create("File Type Selection");
            Dialog.addMessage("Found paired images:");
            Dialog.addMessage("  3.tif: " + count_3tif + " files");
            Dialog.addMessage("  4.tif: " + count_4tif + " files");
            Dialog.addMessage("  other .tif: " + count_other_tif + " files");
            Dialog.addMessage("");
            Dialog.addChoice("Which files to analyze MNV?", newArray("Use paired images (3.tif/4.tif)", "Use all .tif files"), "Use paired images (3.tif/4.tif)");
            Dialog.show();
            
            choice = Dialog.getChoice();
            
            if (choice == "Use paired images (3.tif/4.tif)") {
                print("Decision: Using '3.tif' (paired with 4.tif, " + count_3tif + " pairs) - User confirmed");
                return "3.tif";
            } else {
                print("Decision: Using '.tif' (all tif files including 3.tif and 4.tif) - User selected");
                return ".tif";
            }
        } else {
            // 他のtifがない場合は自動的に3.tifを使用
            print("Decision: Using '3.tif' (paired with 4.tif, " + count_3tif + " pairs)");
            return "3.tif";
        }
    }
    // 3.tifと4.tifの数が不一致の場合
    else if (count_3tif > 0 && count_4tif > 0 && count_3tif != count_4tif) {
        print("WARNING: Mismatch between 3.tif (" + count_3tif + ") and 4.tif (" + count_4tif + ")");
        if (count_other_tif > 0) {
            print("Decision: Using '.tif' (general tif files due to mismatch)");
            return ".tif";
        } else {
            print("ERROR: Paired images are mismatched and no other .tif files found!");
            exit("Cannot proceed with mismatched paired images.");
        }
    }
    // 3.tifのみ存在する場合
    else if (count_3tif > 0) {
        print("Decision: Using '3.tif' (" + count_3tif + " files found)");
        return "3.tif";
    }
    // 一般的な.tifファイルが存在する場合
    else if (count_other_tif > 0) {
        print("Decision: Using '.tif' (general tif files)");
        return ".tif";
    }
    // ファイルが全く見つからない場合
    else {
        print("ERROR: No suitable .tif files found in the folder!");
        print("Please check the input directory.");
        exit("No .tif files found. Analysis cannot proceed.");
    }
}
function initializeArrays(size) {
    MNV_Areas = newArray(size);
    vessel_Areas = newArray(size);
    vessel_Junctions = newArray(size);
    vessel_Branches = newArray(size);
    Corrected_vessel_diameters = newArray(size);
    vessel_Lengths = newArray(size);
    Corrected_vessel_length = newArray(size);
    fractal_dimensions = newArray(size);
    highSkewPercentage = newArray(size);
    end_points = newArray(size);
    triple_points = newArray(size);
    quadruple_points = newArray(size);
    torts = newArray(size);
    vessel_densities = newArray(size);
    junction_densities = newArray(size);
    branch_densities = newArray(size);
    vessel_diameters = newArray(size);
    multiple_densities = newArray(size);
    endpoint_densities = newArray(size);
    skeleton_diameter = newArray(size);
    skeleton_diameter_std = newArray(size);
    skeleton_diameter_max = newArray(size);
    max_mean_ratio = newArray(size);
    max_mean_sd = newArray(size);
    ID = newArray(size);
    mean_intensity = newArray(size);
    MNV_max_mean_ratio = newArray(size);
    standard_deviation = newArray(size);
    vessel_density_index = newArray(size);
    immature_vessel_area_index = newArray(size);
    CV_diameter = newArray(size);
    QC = newArray(size);
    
// 動脈化配列の初期化
	arteriolarization_segment_count = newArray(size);
	arteriolarization_total_length = newArray(size);
	arteriolarization_max_segment_length = newArray(size);
	arteriolarization_density = newArray(size);
	arteriolarization_connectivity_index = newArray(size);
	localized_diameter_variation = newArray(size);

// 空間分布解析用配列の初期化
	diameter_center_mean = newArray(size);
	diameter_periphery_mean = newArray(size);
	diameter_center_periphery_ratio = newArray(size);
	diameter_radial_gradient = newArray(size);
	thick_vessel_center_ratio = newArray(size);
	thick_vessel_periphery_ratio = newArray(size);
	center_branch = newArray(size);
	periphery_branch = newArray(size);

// MNVサブタイプ分類用配列の初期化
	vessel_density_center = newArray(size);
	vessel_density_periphery = newArray(size);
	vessel_density_ratio = newArray(size);
	branch_density_center = newArray(size);
	branch_density_periphery = newArray(size);
	branch_density_ratio = newArray(size);
	junction_density_center = newArray(size);
	junction_density_periphery = newArray(size);
	mean_diameter_center = newArray(size);
	mean_diameter_periphery = newArray(size);
	loop_center = newArray(size);
	loop_periphery = newArray(size);
	mnv_subtype = newArray(size);
	subtype_confidence = newArray(size);
	stability_score = newArray(size);
	complexity_score = newArray(size);
	maturity_index  = newArray(size);
	// ========================================
    // FD / Euler / Tortuosity / Vessel Length 配列の初期化
    // ========================================
    FD_center = newArray(size);
    FD_periphery = newArray(size);
    euler_center = newArray(size);
    euler_periphery = newArray(size);
    vessel_length_center = newArray(size);
    vessel_length_periphery = newArray(size);
    tortuosity_center = newArray(size);
    tortuosity_periphery = newArray(size);
	trunk_eccentricity = newArray(size);
	angular_distribution_cv = newArray(size);
    


    FD_percent_R1 = newArray(size);
    FD_percent_R2 = newArray(size);
    FD_percent_R3 = newArray(size);
    FD_average_area_R1 = newArray(size);
    FD_average_area_R2 = newArray(size);
    FD_average_area_R3 = newArray(size);
    FD_number_R1 = newArray(size);
    FD_number_R2 = newArray(size);
    FD_number_R3 = newArray(size);
    FD_number_per_length_R1 = newArray(size);
    FD_number_per_length_R2 = newArray(size);
    FD_number_per_length_R3 = newArray(size);
    FD_density_R1 = newArray(size);
    FD_density_R2 = newArray(size);
    FD_density_R3 = newArray(size);
    FD_ring_index_R1 = newArray(size);
    FD_ring_index_R2 = newArray(size);
    FD_ring_index_R3 = newArray(size);
    
}

function countFilesInFolder(folder, suffix) {
    list = getFileList(folder);
    for (i = 0; i < list.length; i++) {
        if (endsWith(list[i], "/")) {
            countFilesInFolder(folder + File.separator + list[i], suffix);
        } else if (endsWith(list[i].toLowerCase(), suffix.toLowerCase())) {
            mnv_number_of_images++;
        }
    }
}

function processFolder(input) {
    list = getFileList(input);
    list = Array.sort(list);
    
    filteredList = newArray();
    successCount = 0;
    errorCount = 0;
    
    print("=== Folder processing started: " + input + " ===");
    print("Target file count: " + mnv_number_of_images);
    
    for (i = 0; i < list.length; i++) {
        fullPath = input + File.separator + list[i];
        if (File.isDirectory(fullPath)) {
            processFolder(fullPath);
        } else if (endsWith(list[i], mnv_suffix)) {
            filteredList = Array.concat(filteredList, list[i]);
            // サフィックスを除いたIDを取得
            patient_id = replace(list[i], mnv_suffix, "");
            ID[index] = patient_id;            
            print("Processing started (" + (index + 1) + "/" + mnv_number_of_images + "): " + list[i]);
            
            result = processFileImproved(input, t_output, s_output, list[i]);
            
            resultSuccess = (result[0] == "true");
            resultQuality = result[1];
            
            if (resultSuccess) {
                successCount++;
                print("Processing successful: " + list[i] + " (quality: " + resultQuality + ")");
            } else {
                errorCount++;
                if (result.length > 3) {
    				resultError = result[3];
				} else {
				    resultError = "Unknown error";
				}
                print("Processing failed: " + list[i] + " - " + resultError);
            }
        }
    }
    
    print("=== Folder processing completed ===");
    print("Success: " + successCount + " / Failed: " + errorCount + " / Total: " + mnv_number_of_images);
    
    globalFilteredList = filteredList;
}

function processFileImproved(input, t_output, s_output, file) {
    print("=== File processing started: " + file + " ===");
    
    while (nImages > 0) {
    selectImage(nImages);
    close();
    }
    
    setupResult = performInitialSetup(input, file);
    if (!setupResult) {
        print("Error: Initial setup failed - " + file);
        result = createFailedResult(file, "Initial setup failed");
        cleanupResources();
        return result;
    }
    
    enableBatchMode(true);
    
    preprocessSuccess = performImagePreprocessing();
    if (!preprocessSuccess) {
        resetBatchMode();
        result = createFailedResult(file, "Image preprocessing failed");
        cleanupResources();
        return result;
    }    
    
    skeletonSuccess = performSkeletonAnalysisImproved();
    if (!skeletonSuccess) {
        resetBatchMode();
        result = createFailedResult(file, "Skeleton analysis failed");
        cleanupResources();
        return result;
    }
    
    createVisualizationRGB();

    visualizationSuccess = createResultVisualization(s_output, file);
    
    fdSuccess = performFlowDeficitAnalysisImproved(file);
    if (!fdSuccess) {
        print("Warning: Flow Deficit analysis issue");
    }

    
    finalResult = getUserValidation(file, stability_score [index], complexity_score [index]);
    
    cleanupResources();
    
    print("=== File processing completed: " + file + " ===");
    return finalResult;
}

function performInitialSetup(input, file) {
    print("Initial setup started: " + file);
    
    fullPath = input + File.separator + file;
    if (!File.exists(fullPath)) {
        print("Error: File does not exist - " + fullPath);
        return false;
    }
    
    open(fullPath);
    if (nImages == 0) {
        print("Error: Could not open image - " + file);
        return false;
    }
    
    originalimage = getImageID();
    imageWidth = getWidth();
    imageHeight = getHeight(); 

    run("8-bit");
    run("Set Scale...", "distance=" + imageWidth + " known=" + scale_mm + " unit=mm");
    run("Set Measurements...", "area standard shape area_fraction redirect=None decimal=3");
    setOption("BlackBackground", true);
    setBackgroundColor(0, 0, 0);
    
    ROI_semiauto_improved(input + File.separator, file);
    
    if (roiManager("count") == 0) {
        print("Error: No ROI set");
        return false;
    }
    
    mm_per_pixcel = scale_mm / imageWidth;
    pixel_size_um = (scale_mm * 1000) / imageWidth;
    
    print("Initial setup completed - ROI count: " + roiManager("count"));
    
    roiManager("Select", roiManager("count") - 1);
    return true;
}

function performImagePreprocessing() {
    print("Image preprocessing started");
    
    if (nImages == 0) {
        print("Error: No processing target image");
        return false;
    }
    
    selectImage(originalimage);
    duplicateForChannels("SOURCE_IMAGE_TITLE", newArray("mex_hat.tif", "tube.tif", "reference.tif"));
    
    phansalkar_rad = Math.round(PHANSALKAR_DESIRED_RADIUS_UM / pixel_size_um);
    
    
    if (selectWindowSafely("reference.tif")) {
    	makeSelection(saved_MNV_type, saved_MNV_xCoords, saved_MNV_yCoords);
		roiManager("add");
    	roiManager("Select", roiManager('count') - 1);
        run("Set Measurements...", "area standard shape area_fraction redirect=None decimal=3");
        run("Measure");
        if (nResults > 0) {
            MNV_Areas[index] = getResult("Area", nResults-1);
            run("Select None");
            run("Duplicate...", "title=crop_reference.tif ignore");
            closeResultsWindow();
        }
    }
    
    mexHatSuccess = processMexicanHatImproved();
    if (!mexHatSuccess) {
        print("Error: Laplacian of Gaussian processing failed");
        return false;
    }
    
    tubenessSuccess = processTubenessImproved();
    if (!tubenessSuccess) {
        print("Error: Tubeness processing failed");
        return false;
    }
    
    binarySuccess = createBinaryImageImproved();
    if (!binarySuccess) {
        print("Error: Binary image creation failed");
        return false;
    }
    
    print("Image preprocessing completed");
    return true;
}

function processMexicanHatImproved() {
    if (!selectWindowSafely("mex_hat.tif")) {
        return false;
    }

    preproc();
    
    if (checkbox_gaussian) {
        width = getWidth();
        radius = width * gaussian_sigma / 100.0;
        run("Gaussian Blur...", "sigma=" + radius);
    }
    
    run("FeatureJ Laplacian", "sigma=" + mexican_hat_filter_radius);
    setOption("BlackBackground", true);
    run("8-bit");
    run("Make Binary");

    denoiseImproved(1);


    print("Laplacian of Gaussian processing completed");
    return true;
}

function processTubenessImproved() {
    if (!selectWindowSafely("tube.tif")) {
        return false;
    }
    
    run("Tubeness", "sigma=" + tubeness_filter_radius);
    run("8-bit");
    run("Auto Local Threshold", "method=Sauvola radius=15 parameter_1=0 parameter_2=0 white");
    setOption("BlackBackground", true);
    rename("tubeness.tif");
    if (isOpen("tube.tif")) {
    close("tube.tif");
	}
    selectWindow("tubeness.tif");

    denoiseImproved(1);



    print("Tubeness processing completed");
    return true;
}
function denoiseImproved(removeSmallParticles) {
    initialROICount = roiManager("count");

    maxIterations = MAX_DESPECKLE_ITERATIONS;

    for (iteration = 0; iteration < maxIterations; iteration++) {
        area1 = -1;
        getStatistics(area1);

        run("Despeckle");
        wait(50);

        area2 = -2;
        getStatistics(area2);
        if (area1 == area2) {
            break;
        }

        if (iteration == maxIterations - 1) {
            print("Warning: Despeckle timeout (fixed limit: " + maxIterations + ")");
        }
    }

    if (removeSmallParticles == 1) {
        removeSmallParticlesImproved(initialROICount);
    }

    cleanupROIs(initialROICount);
    run("Remove Overlay");
}
function removeSmallParticlesImproved(initialROICount) {
    setThreshold(200, 255, "raw");
    setOption("BlackBackground", true);
    run("Analyze Particles...", "size=0-Infinity circularity=0-1.0 display clear show=[Nothing] exclude add");

    currentROICount = roiManager("count");

    if (currentROICount > initialROICount) {
        totalArea = 0;
        particleCount = currentROICount - initialROICount;

        for (i = initialROICount; i < currentROICount; i++) {
            roiManager("select", i);
            getStatistics(area, mean, min, max, std);
            totalArea += area;
        }

        if (particleCount > 0) {
            meanArea = totalArea / particleCount;

            for (i = initialROICount; i < currentROICount; i++) {
                roiManager("select", i);
                getStatistics(area, mean, min, max, std);
                if (area < meanArea) {
                    setColor(0, 0, 0);
                    run("Fill", "slice");
                }
            }
        }
    }

    closeResultsWindow();
}

function createBinaryImageImproved() {
    if (!isOpen("mex_hat.tif") || !isOpen("tubeness.tif")) {
        print("Error: Preprocessing images not found");
        return false;
    }

    imageCalculator("OR create", "mex_hat.tif", "tubeness.tif");

    if (isOpen("Result of mex_hat.tif")) {
        selectWindow("Result of mex_hat.tif");
        rename("binary.tif");
        denoiseImproved(0);

        if (selectWindowSafely("binary.tif")) {
            makeSelection(saved_MNV_type, saved_MNV_xCoords, saved_MNV_yCoords);
			roiManager("add");
    		roiManager("Select", roiManager('count') - 1);
            closeResultsWindow();
            run("Set Scale...", "distance=" + imageWidth + " known=" + scale_mm + " unit=mm");
            run("Set Measurements...", "area area_fraction redirect=None decimal=6");
            run("Measure");

            row = nResults - 1;
            area_total = getResult("Area", row);
            area_frac  = getResult("%Area", row);

            white_area = area_total * (area_frac / 100.0);
            vessel_Areas[index] = white_area;

            closeResultsWindow();
        }
    
    	cleanupIntermediateImages();

        print("Binary image creation completed");
        return true;
    }

    return false;
}

///////////////////////////////////////////////////
///       Flow deficit analysis
///////////////////////////////////////////////////

function performFlowDeficitAnalysisImproved(file) {
    print("Flow Deficit analysis started");
    
    var baseFilename = "";
    var lastDot = lastIndexOf(file, ".");
    var lastUnderscore = lastIndexOf(file, "_");
    
    if (lastDot >= 0 && lastUnderscore >= 0 && lastUnderscore < lastDot) {
        var preExtension = substring(file, 0, lastDot);
        var lastChar = substring(preExtension, lengthOf(preExtension) - 1, lengthOf(preExtension));
        
        if (lastChar >= "0" && lastChar <= "9") {
            baseFilename = substring(preExtension, 0, lengthOf(preExtension) - 1);
        } else {
            baseFilename = preExtension;
        }
    } else {
        if (lastUnderscore >= 0) {
            baseFilename = substring(file, 0, lastUnderscore + 1);
        }
    }
    
    var foundMatch = false;
    list = getFileList(input);
    for (i = 0; i < list.length; i++) {
        filename = list[i];
        if (endsWith(filename, cc_suffix)) {
            var currentBase = "";
            var fileDot = lastIndexOf(filename, ".");
            var fileUnderscore = lastIndexOf(filename, "_");
            
            if (fileDot >= 0 && fileUnderscore >= 0 && fileUnderscore < fileDot) {
                var filePreExt = substring(filename, 0, fileDot);
                var fileLastChar = substring(filePreExt, lengthOf(filePreExt) - 1, lengthOf(filePreExt));
                
                if (fileLastChar >= "0" && fileLastChar <= "9") {
                    currentBase = substring(filePreExt, 0, lengthOf(filePreExt) - 1);
                } else {
                    currentBase = filePreExt;
                }
            }
            
            if (currentBase == baseFilename) {
                if (isOpen("FD_Image")) {
                    selectWindow("FD_Image");
                    run("Close");
                }
                
                open(input + File.separator + filename);
                originalimage = getImageID();
                rename("FD_Image");
                print("Selected FD image: " + filename);
                foundMatch = true;
                break;
            }
        }
    }
    
    if (!foundMatch) {
        print("Warning: No corresponding " + cc_suffix + "file found for " + file);
        setDefaultFDValues();
        return true;
    }
    
    fdAnalysisSuccess = executeFlowDeficitAnalysis();
    
    return fdAnalysisSuccess;
}

function executeFlowDeficitAnalysis() {
    print("Flow Deficit analysis execution started");

    
    if (!selectWindowSafely("FD_Image")) {
        print("Error: FD_Image not found");
        setDefaultFDValues();
        return true;
    }
    
    originalimage = getImageID();
    run("8-bit");
    
    if (scale_mm > 0 && imageWidth > 0) {
        run("Set Scale...", "distance=" + imageWidth + " known=" + scale_mm + " unit=mm");
        getPixelSize(unit, pw, ph);
    } else {
        print("Warning: Invalid scale parameters - using pixel units");
    }
    
    roiManager("Reset");
    makeSelection(saved_MNV_type, saved_MNV_xCoords, saved_MNV_yCoords);
	roiManager("add");
    roiManager("Select", roiManager('count') - 1);    
    baseROIIndex = roiManager("count") - 1;
    
    if (baseROIIndex < 0 || baseROIIndex >= roiManager("count")) {
        print("ERROR: Invalid base ROI index: " + baseROIIndex);
        return false;
    }
    
    run("Duplicate...", "title=BinaryImage ignore");
    selectWindow("BinaryImage");
    
    getStatistics(area, mean, min, max, std);
    
    phansalkar_rad = Math.round(PHANSALKAR_DESIRED_RADIUS_UM / ((scale_mm * 1000) / imageWidth));
    run("Auto Local Threshold", "method=Phansalkar radius=" + phansalkar_rad + " parameter_1=0 parameter_2=0 white");
    
    run("Convert to Mask");
    run("Invert");
    
    getStatistics(area, mean, min, max, std);
    getHistogram(values, counts, 256);
    print("FD: Final binary - Black pixels: " + counts[0] + ", White pixels: " + counts[255]);
    
    numRings = FD_NUM_RINGS;
    enlargeStep_mm = FD_ENLARGE_STEP_MM;
    
    FD_percent_local = newArray(numRings);
    FD_average_area_local = newArray(numRings);
    FD_number_local = newArray(numRings);
    FD_density_local = newArray(numRings);
    
    outerIndices = newArray(numRings);
    ringIndices = newArray(numRings);
    innerIndices = newArray(numRings);
    
    innerIndices[0] = baseROIIndex;
    
    for (ringNum = 1; ringNum <= numRings; ringNum++) {
        if (ringNum == 1) {
            roiManager("Select", baseROIIndex);
        } else {
            roiManager("Select", outerIndices[ringNum-2]);
            innerIndices[ringNum-1] = outerIndices[ringNum-2];
        }
        
        if (selectionType() == -1) {
            print("ERROR: No ROI selected for ring " + ringNum);
            continue;
        }
        
        run("Enlarge...", "enlarge=" + enlargeStep_mm + " unit=mm");
        
        if (selectionType() == -1) {
            print("ERROR: Enlarge operation failed for ring " + ringNum);
            continue;
        }
        
        roiManager("Add");
        outerIndex = roiManager("count") - 1;
        outerIndices[ringNum-1] = outerIndex;
        
        if (ringNum == 1) {
            innerIndex = baseROIIndex;
        } else {
            innerIndex = outerIndices[ringNum-2];
        }
        
        if (innerIndex >= roiManager("count") || outerIndex >= roiManager("count")) {
            print("ERROR: Invalid ROI indices for XOR");
            continue;
        }
        
        run("Select None");
        roiManager("Select", newArray(innerIndex, outerIndex));
        roiManager("XOR");
        
        if (selectionType() == -1) {
            print("ERROR: XOR operation failed for ring " + ringNum);
            continue;
        }
        
        roiManager("Add");
        ringIndex = roiManager("count") - 1;
        ringIndices[ringNum-1] = ringIndex;
    }
    
    run("Set Measurements...", "area perimeter redirect=None decimal=3");
    
    for (ringNum = 1; ringNum <= numRings; ringNum++) {
        selectWindow("BinaryImage");
        ringROI = ringIndices[ringNum-1];
        
        if (ringROI >= roiManager("count") || ringROI < 0) {
            print("ERROR: Ring index out of bounds for ring " + ringNum);
            FD_percent_local[ringNum-1] = 0;
            FD_average_area_local[ringNum-1] = 0;
            FD_number_local[ringNum-1] = 0;
            FD_density_local[ringNum-1] = 0;
            continue;
        }
        
        run("Select None");
        roiManager("Select", ringROI);
        
        if (selectionType() == -1) {
            print("ERROR: No selection for ring " + ringNum);
            FD_percent_local[ringNum-1] = 0;
            FD_average_area_local[ringNum-1] = 0;
            FD_number_local[ringNum-1] = 0;
            FD_density_local[ringNum-1] = 0;
            continue;
        }
        
        run("Clear Results");
        run("Measure");
        
        if (nResults == 0) {
            print("ERROR: No measurement results for ring " + ringNum);
            continue;
        }
        
        roiArea_mm2 = getResult("Area", nResults-1);
        roiPerimeter_mm = getResult("Perim.", nResults-1);
        roiArea_um2 = roiArea_mm2 * 1.0e6;
        
        if (roiArea_mm2 <= 0) {
            print("WARNING: Ring " + ringNum + " has zero or negative area");
            FD_percent_local[ringNum-1] = 0;
            FD_average_area_local[ringNum-1] = 0;
            FD_number_local[ringNum-1] = 0;
            FD_density_local[ringNum-1] = 0;
            continue;
        }
        
        selectWindow("BinaryImage");
        roiManager("Select", ringROI);
        
        getHistogram(values, counts, 256);
        blackPixels = counts[0];
        whitePixels = counts[255];
        totalPixelsInROI = blackPixels + whitePixels;
                
        getPixelSize(unit, pixelWidth, pixelHeight);
        pixelArea_mm2 = pixelWidth * pixelHeight;
        
        fdPixelArea_um2 = blackPixels * pixelArea_mm2 * 1.0e6;
        
        nParticles = 0;
        totalFDArea_um2 = 0;
        
        if (blackPixels > 0) {
            setThreshold(0, 127);
            run("Set Measurements...", "area mean redirect=None decimal=3");
            run("Analyze Particles...", "size=0-Infinity circularity=0.00-1.00 show=Nothing clear");
            nParticles = nResults;
            
            if (nParticles > 0) {
                totalFDArea_um2 = 0;
                for (r = 0; r < nResults; r++) {
                    particleArea_mm2 = getResult("Area", r);
                    totalFDArea_um2 += particleArea_mm2 * 1.0e6;
                }
            } else if (blackPixels > 0) {
                nParticles = 1;
                totalFDArea_um2 = fdPixelArea_um2;
            }
        }
        
        if (roiArea_um2 > 0) {
            FD_percent_local[ringNum-1] = (totalFDArea_um2 / roiArea_um2) * 100;
        } else {
            FD_percent_local[ringNum-1] = 0;
        }
        
        if (nParticles > 0) {
            FD_average_area_local[ringNum-1] = totalFDArea_um2 / nParticles;
        } else {
            FD_average_area_local[ringNum-1] = 0;
        }
        
        FD_number_local[ringNum-1] = nParticles;
        
        if (roiArea_mm2 > 0) {
            FD_density_local[ringNum-1] = nParticles / roiArea_mm2;
        } else {
            FD_density_local[ringNum-1] = 0;
        }
        
        print("Ring " + ringNum + " completed: " + nParticles + " particles, " + 
              d2s(FD_percent_local[ringNum-1], 2) + "% FD");
    }
    
    FD_percent_R1[index] = FD_percent_local[0];
    FD_percent_R2[index] = FD_percent_local[1];
    FD_percent_R3[index] = FD_percent_local[2];
    FD_average_area_R1[index] = FD_average_area_local[0];
    FD_average_area_R2[index] = FD_average_area_local[1];
    FD_average_area_R3[index] = FD_average_area_local[2];
    FD_number_R1[index] = FD_number_local[0];
    FD_number_R2[index] = FD_number_local[1];
    FD_number_R3[index] = FD_number_local[2];
    FD_density_R1[index] = FD_density_local[0];
    FD_density_R2[index] = FD_density_local[1];
    FD_density_R3[index] = FD_density_local[2];

/// visualization of flow deficit


if (checkbox) {
selectWindow("BinaryImage");

// Convert to RGB for visualization
run("RGB Color");
run("Split Channels");

for (ringNum = 1; ringNum <= numRings; ringNum++) {
    if (ringNum-1 < ringIndices.length) {
        ringROI = ringIndices[ringNum-1];
        
        if (ringROI >= 0 && ringROI < roiManager("count")) {

            // For the blue channel, delete only ring 1–3 instead of setting values
            selectWindow("BinaryImage (blue)");
            roiManager("Select", ringROI);
            if (ringNum == 1 || ringNum == 2 || ringNum == 3) {
                run("Clear", "slice"); // Delete pixels from blue channel
            }
        }
    }
}
// After processing all rings, merge the channels again into an RGB composite

run("Merge Channels...", "c1='BinaryImage (red)' c2='BinaryImage (green)' c3='BinaryImage (blue)' create");
run("RGB Color");
    saveStageImproved(s_output, file, "", "FD_");
}

    if (isOpen("BinaryImage")) {
        selectWindow("BinaryImage");
        run("Close");
    }
    
    roiManager("Reset");
    
    print("Flow Deficit analysis completed");
    return true;
}
    
    
function performSkeletonAnalysisImproved() {
    print("Skeleton analysis started");
    
    if (!selectWindowSafely("binary.tif")) {
        return false;
    }
    
    run("Select None");
    run("Duplicate...", "title=skeleton.tif ignore");
    run("Skeletonize");
    
    if (selectWindowSafely("skeleton.tif")) {
        makeSelection(saved_MNV_type, saved_MNV_xCoords, saved_MNV_yCoords);
		roiManager("add");
    	roiManager("Select", roiManager('count') - 1);
        run("Clear Outside");
        rename("skeleton");
        run("RGB Color");
    }
    
    vesselDiameterSuccess = performVesselDiameterAnalysis();
    if (!vesselDiameterSuccess) {
        print("Warning: Vessel diameter analysis issue");
    }
    
    skeletonDetailSuccess = performSkeletonDetailAnalysis();
           
    print("Skeleton analysis completed");
    return skeletonDetailSuccess;
}

function performVesselDiameterAnalysis() {
    if (!selectWindowSafely("binary.tif")) {
        return false;
    }
    
    selectWindow("binary.tif");
	makeSelection(saved_MNV_type, saved_MNV_xCoords, saved_MNV_yCoords);
	roiManager("add");
    roiManager("Select", roiManager('count') - 1);
    run("Clear Outside");
    run("Select None");
    run("Duplicate...", "title=distance ignore");
    if (selectWindowSafely("distance")) {
        run("Convert to Mask");
        run("Distance Map");
        run("32-bit");
        changeValues(0, 0, NaN);
        getStatistics(area, mean, min, max, std, histogram);

        skeleton_diameter[index] = mean * mm_per_pixcel * 1000;
        skeleton_diameter_std[index] = std * mm_per_pixcel * 1000;
        skeleton_diameter_max[index] = max * mm_per_pixcel * 1000;
        max_mean_ratio[index] = (max - mean) / std;
        max_mean_sd[index] = 100 * std / max;
        
    }
    
    if (MNV_Areas[index] > 0) {
        vessel_densities[index] = vessel_Areas[index] / MNV_Areas[index];
    } else {
        vessel_densities[index] = 0;
    }
    
    return true;
}

function performSkeletonDetailAnalysis() {
    print("Skeleton detailed analysis started");
    
    if (!selectWindowSafely("skeleton")) {
        print("Error: skeleton window not found");
        return false;
    }
    
    run("Make Binary");
    
    maxRetries = SKELETON_MAX_RETRIES;
    analysisSuccess = false;
    
    for (retry = 0; retry < maxRetries; retry++) {
        
        if (isOpen("Results")) {
            selectWindow("Results");
            run("Close");
        }
        
        selectWindow("skeleton");
        run("Analyze Skeleton (2D/3D)", "prune=none calculate show display");
        wait(1000);
        
        if (isOpen("Tagged skeleton")) {
            print("Tagged skeleton created successfully");
            analysisSuccess = true;
            break;
        } else {
            print("Tagged skeleton not created on attempt " + (retry + 1));
            windowList = getList("image.titles");
            print("Currently open windows: " + String.join(windowList, ", "));
        }
        
        wait(1000);
    }
    
    if (!analysisSuccess) {
        print("Error: Could not create Tagged skeleton after " + maxRetries + " attempts");
        setDefaultSkeletonResults();
        return true;
    }
    
    skeletonProcessSuccess = processTaggedSkeleton();
    if (!skeletonProcessSuccess) {
        print("Warning: Tagged skeleton processing failed, using defaults");
        setDefaultSkeletonResults();
    }
    
    if (isOpen("Tagged skeleton (red)")) {
        print("High skewness analysis will be performed");
    } else {
        print("Warning: Skipping high skewness analysis - Tagged skeleton (red) not available");
        highSkewPercentage[index] = 0;
        CV_diameter[index] = 0;
    }
    
    if (isOpen("newskeleton1")) {
        fractalSuccess = performFractalAnalysis();
    } else {
        print("Warning: Skipping fractal analysis - newskeleton1 not available");
        fractal_dimensions[index] = 0;
    }
    
    if (isOpen("newskeleton1")) {
        finalSkeletonSuccess = performFinalSkeletonAnalysis();
    } else {
        print("Warning: Skipping final skeleton analysis - newskeleton1 not available");
        setDefaultSkeletonResults();
    }

    skewnessSuccess = performHighSkewnessAnalysis();
    if (!skewnessSuccess) {
        print("Warning: Skewness analysis had issues");
    }
    
    cleanupSkeletonChannels();
    
    print("Skeleton detailed analysis completed");
    return true;
}

function processTaggedSkeleton() {
    
    if (!isOpen("Tagged skeleton")) {
        print("Error: Tagged skeleton window not found");
        return false;
    }
    
    if (!selectWindowSafely("Tagged skeleton")) {
        return false;
    }
    
    run("RGB Color");
    wait(500);
    run("Split Channels");
    wait(500);
    
    
    maxarea = 0;
    
    blueChannelName = "";
    redChannelName = "";
    
    possibleBlueNames = newArray("Tagged skeleton (blue)", "C3-Tagged skeleton", "Tagged skeleton-1", "blue");
    possibleRedNames = newArray("Tagged skeleton (red)", "C1-Tagged skeleton", "Tagged skeleton-3", "red");
    
    for (i = 0; i < possibleBlueNames.length; i++) {
        if (isOpen(possibleBlueNames[i])) {
            blueChannelName = possibleBlueNames[i];
            break;
        }
    }
    
    for (i = 0; i < possibleRedNames.length; i++) {
        if (isOpen(possibleRedNames[i])) {
            redChannelName = possibleRedNames[i];
            break;
        }
    }
    
    if (blueChannelName != "") {
        if (selectWindowSafely(blueChannelName)) {
            run("Convert to Mask");
            
            initialROICount = roiManager("count");
            setOption("BlackBackground", true);
            run("Analyze Particles...", "size=0-Infinity circularity=0-1.0 display clear show=[Nothing] exclude add");
            
            currentROICount = roiManager("count");
            
            for (ind = initialROICount; ind < currentROICount; ind++) {
                roiManager("select", ind);
                getStatistics(area, mean, min, max, std);
                if (area > maxarea) {
                    maxarea = area;
                }
            }
            
            cleanupROIs(initialROICount);
            closeResultsWindow();
        }
    } else {
        print("Warning: Blue channel not found, cannot create refined skeleton");
        return false;
    }
    
    if (redChannelName != "") {
        if (redChannelName != "Tagged skeleton (red)") {
            selectWindow(redChannelName);
            rename("Tagged skeleton (red)");
        }
        
        if (blueChannelName != "" && blueChannelName != "Tagged skeleton (blue)") {
            selectWindow(blueChannelName);
            rename("Tagged skeleton (blue)");
        }
        
        refinedSkeletonSuccess = createRefinedSkeleton(maxarea);
        
        return refinedSkeletonSuccess;
    } else {
        print("Warning: Red channel not found, cannot create refined skeleton");
        return false;
    }
}

function createRefinedSkeleton(maxarea) {
    if (!selectWindowSafely("Tagged skeleton (red)")) {
        print("Error: Tagged skeleton (red) not available for refined skeleton creation");
        return false;
    }
    
    run("Convert to Mask");
    
    if (!isOpen("Tagged skeleton (blue)")) {
        print("Warning: Tagged skeleton (blue) not available, skipping subtraction");
        rename("newskeleton1");
        run("Convert to Mask");
        return true;
    }
    
    imageCalculator("Subtract create", "Tagged skeleton (red)", "Tagged skeleton (blue)");
    
    if (!selectWindowSafely("Result of Tagged skeleton (red)")) {
        print("Warning: Subtraction result not created, using original red channel");
        if (selectWindowSafely("Tagged skeleton (red)")) {
            rename("newskeleton1");
            run("Convert to Mask");
            return true;
        }
        return false;
    }
    
    run("Convert to Mask");
    setOption("BlackBackground", true);
    setThreshold(200, 255, "raw");
    
    applyDiameterLengthFilter();
    
    if (isOpen("Tagged skeleton (blue)")) {
        imageCalculator("Add create", "Result of Tagged skeleton (red)", "Tagged skeleton (blue)");
        if (isOpen("Result of Result of Tagged skeleton (red)")) {
            selectWindow("Result of Result of Tagged skeleton (red)");
            rename("newskeleton1");
        } else {
            selectWindow("Result of Tagged skeleton (red)");
            rename("newskeleton1");
        }
    } else {
        selectWindow("Result of Tagged skeleton (red)");
        rename("newskeleton1");
    }
   
    removeIsolatedJunctionPoints(maxarea);
    
    run("Convert to Mask");
    return true;
}

// ============================================================
// applyDiameterLengthFilter()
// ============================================================

function applyDiameterLengthFilter() {
    initialROICount = roiManager("count");
    setOption("BlackBackground", true);

    run("Analyze Particles...", "size=0-Infinity circularity=0-1.0 display clear show=[Nothing] exclude add");

    diameterLengthThreshold = 0.7;
    currentROICount = roiManager("count");

    nNewROIs = currentROICount - initialROICount;
    if (nNewROIs <= 0) return;

    diameterArray = newArray(nNewROIs);
    nPointsArray = newArray(nNewROIs);

    if (selectWindowSafely("distance")) {
        for (i = 0; i < nNewROIs; i++) {
            roiIndex = initialROICount + i;
            roiManager("select", roiIndex);
            getStatistics(area, mean, min, max, std);
            diameterArray[i] = mean;

            // 座標数を配列に格納
            getSelectionCoordinates(xpoints, ypoints);
            nPointsArray[i] = xpoints.length;
        }
    } else {
        print("Warning: 'distance' window not found!");
        return;
    }
    keepArray = newArray(nNewROIs);
    for (i = 0; i < nNewROIs; i++) {
        if (nPointsArray[i] > 0 && (diameterArray[i] / nPointsArray[i]) > diameterLengthThreshold)
            keepArray[i] = 1;
        else
            keepArray[i] = 0;
    }

    if (selectWindowSafely("Result of Tagged skeleton (red)")) {
        for (i = 0; i < nNewROIs; i++) {
            if (keepArray[i] == 1) {
                roiIndex = initialROICount + i;
                roiManager("select", roiIndex);
                setColor(0, 0, 0);
                run("Fill", "slice");
            }
        }
    } else {
        print("Warning: 'Result of Tagged skeleton (red)' window not found!");
    }
    cleanupROIs(initialROICount);
    closeResultsWindow();
}


// ============================================================
// removeIsolatedJunctionPoints()
// ============================================================

function removeIsolatedJunctionPoints(maxarea) {

    if (!selectWindowSafely("newskeleton1")) {
        print("Warning: 'newskeleton1' window not found!");
        return;
    }

    run("Make Binary");
    initialROICount = roiManager("count");

    setOption("BlackBackground", true);
    run("Analyze Particles...", "size=0-Infinity circularity=0-1.0 display clear show=[Nothing] exclude add");

    currentROICount = roiManager("count");
    nNewROIs = currentROICount - initialROICount;
    if (nNewROIs <= 0) return;

    areaArray = newArray(nNewROIs);

    for (i = 0; i < nNewROIs; i++) {
        roiIndex = initialROICount + i;
        roiManager("select", roiIndex);
        getStatistics(area, mean, min, max, std);
        areaArray[i] = area;
    }

    removeMask = newArray(nNewROIs);
    for (i = 0; i < nNewROIs; i++) {
        if (areaArray[i] < maxarea)
            removeMask[i] = 1;
        else
            removeMask[i] = 0;
    }

    for (i = 0; i < nNewROIs; i++) {
        if (removeMask[i] == 1) {
            roiIndex = initialROICount + i;
            roiManager("select", roiIndex);
            setColor(0, 0, 0);
            run("Fill", "slice");
        }
    }

    cleanupROIs(initialROICount);
    closeResultsWindow();
}


function performHighSkewnessAnalysis() {
    if (!selectWindowSafely("Tagged skeleton (red)")) {
        return false;
    }
    
    getStatistics(area1, mean1, min1, max1);
    run("Make Binary");
    
    maxIterations = 20;
    iteration = 0;
    
    do {
        wait(100);
        getStatistics(area2, mean2, min2, max2);
        iteration++;
        
        if (iteration >= maxIterations) {
            print("Warning: Binary conversion timeout");
            break;
        }
    } while (area1 != area2 && iteration < maxIterations);
    
    run("Duplicate...", "title=Visualization ignore");
    run("Create Selection");
    roiManager("add");
    
    if (selectWindowSafely("distance") && selectWindowSafely("skeleton")) {
        analyzeArteriolarizationSegments();
    }
    
    // CV_diameter
    if (selectWindowSafely("distance")) {
        getStatistics(area, mean, min, max, std);
        CV_diameter[index] = 100 * std / mean;   
    }
    
    return true;
}


function performFractalAnalysis() {
    if (!selectWindowSafely("newskeleton1")) {
        return false;
    }
    
    run("8-bit");
    setOption("BlackBackground", true);
    run("Convert to Mask");
    
    run("Fractal Box Count...", "box=2,3,4,6,8,12,16,32,64 black");
    
    if (isOpen("Results") && nResults > 0) {
        fractal_dimensions[index] = getResult("D", nResults - 1);
        closeResultsWindow();
    } else {
        fractal_dimensions[index] = 0;
    }
    
    if (isOpen("Plot")) {
        selectWindow("Plot");
        run("Close");
    }
    
    return true;
}

function performFinalSkeletonAnalysis() {
    if (!selectWindowSafely("newskeleton1")) {
        return false;
    }

	run("Set Scale...", "distance=0");
	run("Analyze Skeleton (2D/3D)", "prune=none calculate show display");
        
    if (nResults == 0) {
        print("Warning: Final skeleton analysis yielded no results");
        setDefaultSkeletonResults();
        return true;
    }
    
    extractSkeletonResults();
    processBranchInformation();
    
    return true;
}

function extractSkeletonResults() {
    sumJunctions = 0;
    sumBranches = 0;
    sumEndpoints = 0;
    sumTriple = 0;
    sumQuadruple = 0;
    
    for (i = 0; i < nResults; i++) {
        sumJunctions += getResult("# Junctions", i);
        sumBranches += getResult("# Branches", i);
        sumTriple += getResult("# Triple points", i);
        sumQuadruple += getResult("# Quadruple points", i);
        sumEndpoints += getResult("# End-point voxels", i);
    }
    
    vessel_Junctions[index] = sumJunctions;
    vessel_Branches[index] = sumBranches;
    triple_points[index] = sumTriple;
    quadruple_points[index] = sumQuadruple;
    end_points[index] = sumEndpoints;
    
    closeResultsWindow();
}

function processBranchInformation() {
    if (isOpen("Branch information")) {
        Table.rename("Branch information", "Results");
        
        sumBranchLength = 0;
        sumWeightedTortuosity = 0.0;
        sumFilteredBranchLength = 0.0;
        
        threshold = skeleton_diameter[index] / 1000;
        
        for (i = 0; i < nResults; i++) {
            bl = getResult("Branch length", i);
            ed = getResult("Euclidean distance", i);
            
            sumBranchLength += bl;
            
            if (ed > threshold && ed > 0) {
                t = bl / ed;
                if (!isNaN(t) && t >= 1.0 && t < 10.0) {
                    sumWeightedTortuosity += bl * t;
                    sumFilteredBranchLength += bl;
                }
            }
        }

        vessel_Lengths[index] = sumBranchLength * mm_per_pixcel;
        
        if (sumFilteredBranchLength > 0) {
            torts[index] = sumWeightedTortuosity / sumFilteredBranchLength;
        } else {
            torts[index] = 0.00;
        }
        
        if (isNaN(torts[index]) || torts[index] > 1000) {
            torts[index] = 0.00;
        }
        
        if (vessel_Lengths[index] > 0) {
            vessel_diameters[index] = 1000 * (vessel_Areas[index] / vessel_Lengths[index]);
            branch_densities[index] = vessel_Branches[index] / vessel_Lengths[index];
            junction_densities[index] = vessel_Junctions[index] / vessel_Lengths[index];
            endpoint_densities[index] = end_points[index] / vessel_Lengths[index];
            multiple_densities[index] = (quadruple_points[index] + triple_points[index]) / vessel_Lengths[index];
        }
        
        calculateCorrectedValues();
        
        closeResultsWindow();
    }
}

function calculateCorrectedValues() {
    if (vessel_Lengths[index] > 0 && (triple_points[index] > 0 || quadruple_points[index] > 0)) {
        discriminant = vessel_Lengths[index] * vessel_Lengths[index] - 4 * (triple_points[index]/2 + quadruple_points[index]) * MNV_Areas[index];
        
        if (discriminant >= 0) {
            Corrected_vessel_diameters[index] = 1000 * (vessel_Lengths[index] - Math.sqrt(discriminant)) / (2 * (triple_points[index]/2 + quadruple_points[index]));
        } else {
            Corrected_vessel_diameters[index] = vessel_diameters[index];
        }
        
        Corrected_vessel_length[index] = vessel_Lengths[index] - triple_points[index] * skeleton_diameter[index]/2000 - quadruple_points[index] * skeleton_diameter[index]/1000;
        Corrected_vessel_length[index] = Math.max(Corrected_vessel_length[index], 0);
    } else {
        Corrected_vessel_diameters[index] = vessel_diameters[index];
        Corrected_vessel_length[index] = vessel_Lengths[index];
    }
}

function createResultVisualization(outputDir, file) {
    print("Result visualization creation started");
    
    if (!selectWindowSafely("Visualization_RGB")) {
        print("Error: Visualization_RGB not available for visualization");
        return false;
    }
    
    parameters = "Area: " + d2s(vessel_Areas[index], 2);
    saveStageImproved(outputDir, file, parameters, "MNV_");
    
    print("Result visualization completed");
    return true;
}

function saveStageImproved(outputDir, file, text, nameString) {
    if (!checkbox) return;
    
    run("Duplicate...", "title=duplicate.jpg ignore");
    if (!selectWindowSafely("duplicate.jpg")) return;
    
    if (text != "") {
        width = getWidth();
        height = getHeight();
        fontSize = height * 0.05;
        
        setFont("SanSerif", fontSize, "Plain");
        textWidth = getStringWidth(text);
        x = (width - textWidth) / 2;
        y = height - (fontSize * 2.1);
        
        setForegroundColor(255, 255, 255);
        makeText(text, x, y);
        run("Add Selection...");
        run("Fill", "slice");
    }
    
    run("Scale Bar...", "width=0.5 height=0.2 color=Yellow horizontal bold overlay");
    
    outputPath = outputDir + File.separator + nameString + file;
    saveAs("jpg", outputPath);
    run("Close");
}

function getUserValidation(file, stability_score, complexity_score){
	// Close all image windows except "Visualization_RGB"
	titles = getList("image.titles");
	for (i=0; i<titles.length; i++) {
		if (titles[i] != "Visualization_RGB") {
			selectImage(titles[i]);
			close();
		}
	}
	disableBatchMode();
	if (isOpen("Visualization_RGB")) {
		selectWindow("Visualization_RGB");
		run("Maximize");
	}
	// Check for 0 conditions
	needsHigherResolution = false;
    if (stability_score == 0 || isNaN(complexity_score)) {
	print("WARNING: 画像サイズを上げて解析が必要です");
	needsHigherResolution = true;
    }
    
    
	Dialog.create("Analysis Result Confirmation");
	Dialog.addMessage("File: " + file);

	Dialog.addMessage("Is the analysis appropriate?");
	
	// Set default choice based on condition
	if (needsHigherResolution) {
		Dialog.addChoice("Choice:", newArray("Analysis result quality is low", "Yes"));
	} else {
		Dialog.addChoice("Choice:", newArray("Yes", "Analysis result quality is low"));
	}
	
	Dialog.show();
	
	userChoice = Dialog.getChoice();
	
	run("Close All");
	
if (userChoice == "Yes") {
    QC[index] = "Pass";
    index++;
    return newArray("true", "Pass", file, "");
} else {
    QC[index] = "Fail";
    index++;
    
    // Failの場合の処理
    fullPath = input + File.separator + file;
    if (!File.exists(fullPath)) {
        print("Error: File does not exist - " + fullPath);
        return newArray("true", "Fail", file, "QC rejected");
    }
    
    open(fullPath);
    if (nImages == 0) {
        print("Error: Could not open image - " + file);
        return newArray("true", "Fail", file, "QC rejected");
    }
    
    // 画像サイズを4倍に
    quadrupleimgsize();
    
    // 再解析用フォルダーの作成（t_output内に作成）
    reanalyzeDir = t_output + File.separator + "To_be_reanalyzed";
    if (!File.exists(reanalyzeDir)) {
        File.makeDirectory(reanalyzeDir);
    }
    
    // 画像の保存
    run("Duplicate...", "title=duplicate.tif ignore");
    if (selectWindowSafely("duplicate.tif")) {
        outputPath = reanalyzeDir + File.separator + file;
        saveAs("tif", outputPath);
        run("Close");
    }
    
    // 元の画像を閉じる
    close();
    
    return newArray("true", "Fail", file, "QC rejected");
}
}

function createMeasurementsTable() {
    print("Measurements table creation started");
    
    tableName = "measurements";
    Table.create(tableName);
    Table.setColumn("ID", ID);
    Table.setColumn("File", globalFilteredList);
    Table.setColumn("Subtype", mnv_subtype);

	Table.setColumn("MNV Area (mm2)", MNV_Areas);
    Table.setColumn("Vsl Area (mm2)", vessel_Areas);
    Table.setColumn("Vsl Density (Vessel Area/MNV (%))", vessel_densities);
    Table.setColumn("Vessel density index adjusted by signal intensity (aVDI)", vessel_density_index);
    Table.setColumn("MNV Area adjusted by signal intensity (aMNV)", immature_vessel_area_index);
    Table.setColumn("Vsl Length (mm)", Corrected_vessel_length);
    Table.setColumn("Dilated vessel (%)", highSkewPercentage);

	Table.setColumn("Maturity Index",maturity_index);

	Table.setColumn("Caliber Uniformity Score",stability_score);
	Table.setColumn("Network Complexity Score",complexity_score);

    Table.setColumn("Junction Density (n/mm)", junction_densities);
    Table.setColumn("End Pts Density (n/mm)", endpoint_densities);
    Table.setColumn("Multi-Branch Pts Density (n/mm)", multiple_densities);
    Table.setColumn("Branch Density (n/mm)", branch_densities);

	Table.setColumn("Arteriolarization Segment Count", arteriolarization_segment_count);
	Table.setColumn("Arteriolarization Total Length (mm)", arteriolarization_total_length);
	Table.setColumn("Arteriolarization Max Segment Length (mm)", arteriolarization_max_segment_length);
	Table.setColumn("Arteriolarization Density (/mm²)", arteriolarization_density);
	Table.setColumn("Arteriolarization Connectivity Index (mm/segment)", arteriolarization_connectivity_index);
	Table.setColumn("Local Diameter Variation (max CV%)", localized_diameter_variation);

	Table.setColumn("Center Branches", center_branch);
	Table.setColumn("Center Total Length (mm)", vessel_length_center);
	Table.setColumn("Center Tortuosity", tortuosity_center);
	Table.setColumn("Center FD (Box-Counting)", FD_center);
	Table.setColumn("Center Euler Number", euler_center);
	Table.setColumn("Center Loop Number", loop_center);

	Table.setColumn("Periphery Branches", periphery_branch);
	Table.setColumn("Periphery Total Length (mm)", vessel_length_periphery);
	Table.setColumn("Periphery Tortuosity", tortuosity_periphery);
	Table.setColumn("Periphery FD (Box-Counting)", FD_periphery);
	Table.setColumn("Periphery Euler Number", euler_periphery);
	Table.setColumn("Periphery Loop Number", loop_periphery);

    
    Table.setColumn("MNV mean gray intensity (AU)", mean_intensity);
    Table.setColumn("Fractal Dim", fractal_dimensions);
    Table.setColumn("Tortuosity", torts);
        
    Table.setColumn("MNV intensity Variation (CV)", standard_deviation);
    Table.setColumn("NV Diameter (CV)", CV_diameter);
    
    Table.setColumn("(Skel) Vsl Diameter", skeleton_diameter);
    Table.setColumn("End Pts", end_points);
    Table.setColumn("Vsl Branches", vessel_Branches);
    Table.setColumn("Vsl Junctions", vessel_Junctions);
    Table.setColumn("Triple Pts", triple_points);
    Table.setColumn("Quadruple Pts", quadruple_points);
    Table.setColumn("Raw Vsl Length", vessel_Lengths);
    Table.setColumn("Raw Vsl Diameter", vessel_diameters);
    Table.setColumn("Quality of analysis", QC);

    Table.setColumn("FD% (R1)", FD_percent_R1);
    Table.setColumn("FD Avg Area µm² (R1)", FD_average_area_R1);
    Table.setColumn("FD number (R1)", FD_number_R1);
    Table.setColumn("FD density /mm² (R1)", FD_density_R1);
    
    Table.setColumn("FD% (R2)", FD_percent_R2);
    Table.setColumn("FD Avg Area µm² (R2)", FD_average_area_R2);
    Table.setColumn("FD number (R2)", FD_number_R2);
    Table.setColumn("FD density /mm² (R2)", FD_density_R2);
    
    Table.setColumn("FD% (R3)", FD_percent_R3);
    Table.setColumn("FD Avg Area µm² (R3)", FD_average_area_R3);
    Table.setColumn("FD number (R3)", FD_number_R3);
    Table.setColumn("FD density /mm² (R3)", FD_density_R3);


    resOut = t_output + File.separator + mainFolder + "_MNV.csv";
    saveAs(tableName, resOut);
    
    csvWindow = mainFolder + "_MNV.csv";
    if (isOpen(csvWindow)) {
        selectWindow(csvWindow);
        run("Close");
    }
    
    print("Measurements table save completed: " + resOut);
}

function saveProcessingParameters() {
    MonthNames = newArray("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec");
    DayNames = newArray("Sun", "Mon","Tue","Wed","Thu","Fri","Sat");
    getDateAndTime(year, month, dayOfWeek, dayOfMonth, hour, minute, second, msec);
    
    TimeString = "Date, " + DayNames[dayOfWeek] + " ";
    if (dayOfMonth < 10) {TimeString = TimeString + "0";}
    TimeString = TimeString + dayOfMonth + "-" + MonthNames[month] + "-" + year + "\nTime, ";
    if (hour < 10) {TimeString = TimeString + "0";}
    TimeString = TimeString + hour + ":";
    if (minute < 10) {TimeString = TimeString + "0";}
    TimeString = TimeString + minute + ":";
    if (second < 10) {TimeString = TimeString + "0";}
    TimeString = TimeString + second;
    
    outputFilePath = t_output + File.separator + mainFolder + "_Parameter.csv";
    
    if (!File.exists(outputFilePath)) {
        File.open(outputFilePath);
        File.append("Parameter,Value\n", outputFilePath);
    }
    
    File.append("" + TimeString + "\n", outputFilePath);
    File.append("Width (mm)," + scale_mm + "\n", outputFilePath);
    File.append("Tubeness Filter Sigma," + tubeness_filter_radius + "\n", outputFilePath);
    File.append("Laplacian of Gaussian Filter Sigma," + mexican_hat_filter_radius + "\n", outputFilePath);
    File.append("Processed Files," + mnv_number_of_images + "\n", outputFilePath);

    
    print("Parameter save completed: " + outputFilePath);
}

function setDefaultSkeletonResults() {
    vessel_Junctions[index] = 0;
    vessel_Branches[index] = 0;
    triple_points[index] = 0;
    quadruple_points[index] = 0;
    end_points[index] = 0;
    vessel_Lengths[index] = 0;
    vessel_diameters[index] = 0;
    torts[index] = 0;
    fractal_dimensions[index] = 0;
    branch_densities[index] = 0;
    junction_densities[index] = 0;
    endpoint_densities[index] = 0;
    multiple_densities[index] = 0;
    Corrected_vessel_diameters[index] = 0;
    Corrected_vessel_length[index] = 0;
}

function setDefaultFDValues() {
    FD_percent_R1[index] = 0;
    FD_percent_R2[index] = 0;
    FD_percent_R3[index] = 0;
    FD_average_area_R1[index] = 0;
    FD_average_area_R2[index] = 0;
    FD_average_area_R3[index] = 0;
    FD_number_R1[index] = 0;
    FD_number_R2[index] = 0;
    FD_number_R3[index] = 0;
    FD_density_R1[index] = 0;
    FD_density_R2[index] = 0;
    FD_density_R3[index] = 0;
}

function createFailedResult(file, error) {
    resultSuccess = false;
    resultFileId = file;
    resultQualityControl = "Failed";
    resultError = error;
    
    QC[index] = resultQualityControl;
    MNV_Areas[index] = 0;
    vessel_Areas[index] = 0;
    vessel_densities[index] = 0;
    
    index++;
    
    return newArray("false", resultQualityControl, resultFileId, resultError);
}

// =====================================================================
// SHARED UTILITY FUNCTIONS
// =====================================================================

function safeRoiClose() {
    if (isOpen("ROI Manager")) {
        selectWindow("ROI Manager");
        run("Close");
    }
}

function expandROI() {
    sel = selectionType();
    if (sel < 2 || sel > 4) return;
    
    getSelectionCoordinates(x, y);
    run("Select None");
    makeSelection("polygon", x, y);
    l = x.length;
    nx = newArray(l);
    ny = newArray(l);
    
    for (i = 1; i < l - 1; i++) {
        nx[i] = round(((x[i-1] + x[i] + x[i+1]) / 3) + random - 0.5);
        ny[i] = round(((y[i-1] + y[i] + y[i+1]) / 3) + random - 0.5);
    }
    
    nx[0] = round(((x[l-2] + x[0] + x[1]) / 3) + random - 0.5);
    ny[0] = round(((y[l-2] + y[0] + y[1]) / 3) + random - 0.5);
    nx[l-1] = nx[0];
    ny[l-1] = ny[0];
    
    run("Select None");
    tot = 0;
    for (i = 1; i < l; i++) {
        if ((nx[i] == nx[i-1]) && (ny[i] == ny[i-1])) {
            tot++;
        }
    }
    
    if (tot > 0) {
        nex = newArray(l - tot);
        ney = newArray(l - tot);
        nex[0] = nx[0];
        ney[0] = ny[0];
        st = 0;
        for (j = 1; j < l; j++) {
            if ((nx[j] != nx[j-1]) || (ny[j] != ny[j-1])) {
                st++;
                nex[st] = nx[j];
                ney[st] = ny[j];
            }
        }
        nex[l - tot - 1] = nex[0];
        ney[l - tot - 1] = ney[0];
        makeSelection("polygon", nex, ney);
    } else {
        makeSelection("polygon", nx, ny);
    }
}

function ROI_semiauto_improved(path, file) {
    if (roiManager("count") > 0) {
        roiManager("reset");
        print("ROI Manager reset - cleared previous ROIs");
    }
    
    if (image_number == 0) {
        run("Maximize");
        setTool("freehand");
        waitForUser("Please manually specify ROI", "After selecting ROI, click OK");
        
        if (selectionType() != -1) {
            ROI_modify();
            roiManager("Add");
        } else {
            print("Warning: No ROI selected");
        }
    }
    
    roiManager("deselect");
    if (checkbox_seq) {
        image_number = image_number + 1;
    }
}

// ===== ROI Modification Function =====
function ROI_modify() {
    // Check if ROI already exists
    id = getImageID();

    // Add ROI on screen to ROI Manager
    roiManager("add");
    roiManager("Select", roiManager("count") - 1);

    // Get ROI coordinates
    getSelectionCoordinates(originalXPoints, originalYPoints);
    nPoints = lengthOf(originalXPoints);

    // Prepare new coordinate arrays
    modifiedXPoints = newArray(nPoints);
    modifiedYPoints = newArray(nPoints);
    for (i = 0; i < nPoints; i++) {
        modifiedXPoints[i] = originalXPoints[i];
        modifiedYPoints[i] = originalYPoints[i];
    }

    // Calculate centroid
    centroidX = 0;
    centroidY = 0;
    for (i = 0; i < lengthOf(originalXPoints); i++) {
        centroidX += originalXPoints[i];
        centroidY += originalYPoints[i];
    }
    centroidX /= lengthOf(originalXPoints);
    centroidY /= lengthOf(originalYPoints);

    // Calculate angle for each point
    angles = newArray(lengthOf(originalXPoints));
    for (i = 0; i < lengthOf(originalXPoints); i++) {
        dx = originalXPoints[i] - centroidX;
        dy = originalYPoints[i] - centroidY;
        angles[i] = atan2(dy, dx);
    }

    // Sort indices according to angle
    indices = newArray(lengthOf(originalXPoints));
    for (i = 0; i < lengthOf(originalXPoints); i++) {
        indices[i] = i;
    }

    // Sort indices in angle order using bubble sort
    for (i = 0; i < lengthOf(indices) - 1; i++) {
        for (j = 0; j < lengthOf(indices) - i - 1; j++) {
            if (angles[indices[j]] > angles[indices[j + 1]]) {
                temp = indices[j];
                indices[j] = indices[j + 1];
                indices[j + 1] = temp;
            }
        }
    }

    // Create sorted arrays
    sortedXPoints = newArray(lengthOf(originalXPoints));
    sortedYPoints = newArray(lengthOf(originalYPoints));
    for (i = 0; i < lengthOf(indices); i++) {
        sortedXPoints[i] = originalXPoints[indices[i]];
        sortedYPoints[i] = originalYPoints[indices[i]];
    }

    // Return sorted arrays to original variables
    originalXPoints = Array.copy(sortedXPoints);
    originalYPoints = Array.copy(sortedYPoints);

    // Initial settings
    iterations = 5;
    searchRadius = 3;

    // Modify ROI
    for (i = 0; i < nPoints; i++) {
        modifiedXPoints[i] = originalXPoints[i];
        modifiedYPoints[i] = originalYPoints[i];
    }

    // Calculate centroid
    centroidX = 0;
    centroidY = 0;
    for (i = 0; i < nPoints; i++) {
        centroidX += modifiedXPoints[i];
        centroidY += modifiedYPoints[i];
    }
    centroidX /= nPoints;
    centroidY /= nPoints;

    // Allowable angle range (radians)
    angleThreshold = 0.5; // ±0.5 radians (approximately 28.6 degrees)

    // Initialize mask as 1D array
    mask = newArray(getWidth() * getHeight());
    for (i = 0; i < lengthOf(mask); i++) {
        mask[i] = 0; // Means unselected
    }

    // Search and update each point
    for (iter = 0; iter < iterations; iter++) {
        for (i = 0; i < nPoints; i++) {
            x = modifiedXPoints[i];
            y = modifiedYPoints[i];
            minIntensity = getPixel(x, y);
            newX = x;
            newY = y;
            minDistance = getWidth();
            minCentroidDistance = getWidth();
            minPreviousPointDistance = getWidth();

            // Get previous selection point
            if (i > 0) {
                prevX = modifiedXPoints[i - 1];
                prevY = modifiedYPoints[i - 1];
            } else {
                prevX = x;
                prevY = y;
            }

            // Calculate direction vector from centroid to current point
            directionX = x - centroidX;
            directionY = y - centroidY;
            norm = sqrt(directionX * directionX + directionY * directionY);
            if (norm != 0) {
                directionX /= norm;
                directionY /= norm;
            }

            for (dx = -searchRadius; dx <= searchRadius; dx++) {
                for (dy = -searchRadius; dy <= searchRadius; dy++) {
                    nx = x + dx;
                    ny = y + dy;

                    // Check out of range
                    if (nx >= 0 && ny >= 0 && nx < getWidth() && ny < getHeight()) {
                        // Calculate vector to search point
                        vectorX = nx - centroidX;
                        vectorY = ny - centroidY;
                        vectorNorm = sqrt(vectorX * vectorX + vectorY * vectorY);
                        if (vectorNorm != 0) {
                            vectorX /= vectorNorm;
                            vectorY /= vectorNorm;
                        }

                        // Calculate angle (get cosθ using inner product)
                        dotProduct = directionX * vectorX + directionY * vectorY;
                        angle = acos(dotProduct); // radians

                        // Skip if angle is not within tolerance range
                        if (abs(angle) > angleThreshold) {
                            continue;
                        }

                        // Minimum value search conditions
                        intensity = getPixel(nx, ny);
                        distance = sqrt(dx * dx + dy * dy);
                        centroidDistance = sqrt((nx - centroidX) * (nx - centroidX) + (ny - centroidY) * (ny - centroidY));
                        previousPointDistance = sqrt((nx - prevX) * (nx - prevX) + (ny - prevY) * (ny - prevY));

                        // Add new conditions
                        if (intensity < minIntensity || 
                           (intensity == minIntensity && distance < minDistance) ||
                           (intensity == minIntensity && distance == minDistance && centroidDistance < minCentroidDistance) ||
                           (intensity == minIntensity && distance == minDistance && centroidDistance == minCentroidDistance && previousPointDistance < minPreviousPointDistance)) {
                            minIntensity = intensity;
                            newX = nx;
                            newY = ny;
                            minDistance = distance;
                            minCentroidDistance = centroidDistance;
                            minPreviousPointDistance = previousPointDistance;
                        }
                    }
                }
            }

            // Update to minimum value coordinates
            modifiedXPoints[i] = newX;
            modifiedYPoints[i] = newY;

            // Update mask array as selected
            indexVal = newY * getWidth() + newX;
            mask[indexVal] = 1;
        }
    }

    // Smoothing processing
    l = modifiedXPoints.length;
    nx = newArray(l);
    ny = newArray(l);

    for (i = 1; i < l - 1; i++) {
        nx[i] = round(((modifiedXPoints[i-1] + modifiedXPoints[i] + modifiedXPoints[i+1]) / 3) + random - 0.5);
        ny[i] = round(((modifiedYPoints[i-1] + modifiedYPoints[i] + modifiedYPoints[i+1]) / 3) + random - 0.5);
    }

    // First and last points
    nx[0] = round(((modifiedXPoints[l-2] + modifiedXPoints[0] + modifiedXPoints[1]) / 3) + random - 0.5);
    ny[0] = round(((modifiedYPoints[l-2] + modifiedYPoints[0] + modifiedYPoints[1]) / 3) + random - 0.5);
    nx[l-1] = nx[0];
    ny[l-1] = ny[0];

    run("Select None");

    // Duplicate check
    tot = 0;
    for (i = 1; i < l; i++) {
        if ((nx[i] == nx[i-1]) && (ny[i] == ny[i-1])) {
            tot++;
        }
    }

    if (tot > 0) {
        nex = newArray(l - tot);
        ney = newArray(l - tot);
        nex[0] = nx[0];
        ney[0] = ny[0];

        st = 0;
        for (j = 1; j < l; j++) {
            if ((nx[j] != nx[j-1]) || (ny[j] != ny[j-1])) {
                st++;
                nex[st] = nx[j];
                ney[st] = ny[j];
            }
        }
        nex[l - tot - 1] = nex[0];
        ney[l - tot - 1] = ney[0];
        roiManager("reset");
        makeSelection("freehand", nex, ney);
        
        getSelectionCoordinates(saved_MNV_xCoords, saved_MNV_yCoords);
        saved_MNV_type = selectionType();
        Roi.getBounds(saved_MNV_x, saved_MNV_y, saved_MNV_width, saved_MNV_height);
        
    } else {
        roiManager("reset");
        makeSelection("freehand", nx, ny);
    }

        getSelectionCoordinates(saved_MNV_xCoords, saved_MNV_yCoords);
        saved_MNV_type = selectionType();
        Roi.getBounds(saved_MNV_x, saved_MNV_y, saved_MNV_width, saved_MNV_height);
        
        makeSelection(saved_MNV_type, saved_MNV_xCoords, saved_MNV_yCoords);

}

function preproc() {
    run("Despeckle");
    setMinAndMax(70, 255);
    setMinAndMax(0, 177);
}

function duplicateForChannels(srcTitle, destNames) {
    for (i = 0; i < destNames.length; i++) {
        selectImage(originalimage);
        run("Duplicate...", "title=" + destNames[i] + " ignore");
    }
    return true;
}

function enableBatchMode(hideWindows) {
    if (!batchModeEnabled) {
        if (hideWindows) {
            setBatchMode("hide");
            batchModeHidden = true;
        } else {
            setBatchMode(true);
            batchModeHidden = false;
        }
        batchModeEnabled = true;
        print("BatchMode enabled - hidden: " + hideWindows);
    }
}

function disableBatchMode() {
    if (batchModeEnabled) {
        setBatchMode(false);
        batchModeEnabled = false;
        batchModeHidden = false;
        forceShowMode = false;
        print("BatchMode disabled");
        wait(100);
    }
}

function temporaryShow() {
    if (batchModeEnabled && batchModeHidden) {
        setBatchMode("show");
        forceShowMode = true;
        wait(200);
        print("BatchMode temporary show");
    }
}

function temporaryHide() {
    if (forceShowMode) {
        setBatchMode("hide");
        forceShowMode = false;
        print("BatchMode re-hide");
    }
}

function resetBatchMode() {
    setBatchMode(false);
    batchModeEnabled = false;
    batchModeHidden = false;
    forceShowMode = false;
    wait(200);
    print("BatchMode force reset completed");
}
// ========================================
// ウィンドウ選択のセーフティ関数
// ========================================

function selectWindowSafely(windowName) {
    maxRetries = 5;
    success = false;
    
    for (retry = 0; retry < maxRetries; retry++) {
        if (isOpen(windowName)) {
            selectWindow(windowName);
            success = true;
            break;
        } else {
            print("Warning: Window not found: " + windowName + " (attempt " + (retry + 1) + ")");
            wait(200);
        }
    }
    
    if (!success) {
        print("Error: Failed to select window: " + windowName);
    }
    
    return success;
}

function closeResultsWindow() {
    if (isOpen("Results")) {
        selectWindow("Results");
        run("Close");
    }
}

function cleanupROIs(fromIndex) {
    while (roiManager("count") > fromIndex) {
        roiManager("Select", roiManager("count") - 1);
        roiManager("delete");
    }
}

function cleanupResources() {
    run("Close All");
    if (roiManager("count") > 0) {
        roiManager("reset");
    }
    call("java.lang.System.gc");
}

function cleanupIntermediateImages() {
    imagesToClose = newArray("mex_hat.tif", "tubeness.tif");
    for (i = 0; i < imagesToClose.length; i++) {
        if (isOpen(imagesToClose[i])) {
            selectWindow(imagesToClose[i]);
            run("Close");
        }
    }
    print("Intermediate images cleaned up");
}

function cleanupSkeletonChannels() {
    imagesToClose = newArray("Tagged skeleton (red)", "Tagged skeleton (green)", "Tagged skeleton (blue)");
    for (i = 0; i < imagesToClose.length; i++) {
        if (isOpen(imagesToClose[i])) {
            selectWindow(imagesToClose[i]);
            run("Close");
        }
    }
    print("Skeleton channel images cleaned up");
}

/////////////////////////////
///   細動脈化セグメント解析
/////////////////////////////

function analyzeArteriolarizationSegments() {
    print("=== 細動脈化セグメント解析開始 ===");
    
    if (mm_per_pixcel == 0 || isNaN(mm_per_pixcel)) {
        print("ERROR: mm_per_pixcel is not properly set");
        setDefaultArteriolarizationValues();
        return false;
    }
    
    // 必要な画像の確認
    if (!selectWindowSafely("distance")) {
        print("Error: distance map not available");
        setDefaultArteriolarizationValues();
        return false;
    }
    
    if (!selectWindowSafely("newskeleton1")) {
        print("Error: skeleton not available");
        setDefaultArteriolarizationValues();
        return false;
    }
    
    // スケルトン上のdistance値を収集
    selectWindow("newskeleton1");
    run("Select None");
    
    selectWindow("distance");
    run("Select None");
    
    // スケルトンとdistanceを掛け算してマスク
    selectWindow("newskeleton1");
    run("Duplicate...", "title=skeleton_binary");
    setThreshold(1, 255);
    run("Convert to Mask");
    run("Divide...", "value=255");

    selectWindow("distance");
    run("Duplicate...", "title=distance_temp");
    run("32-bit");
    
    imageCalculator("Multiply create 32-bit", "distance_temp", "skeleton_binary");
    selectWindow("Result of distance_temp");
    rename("distance_on_skeleton");
    
    // スケルトン上のピクセル値を配列に収集（0を除外）
    selectWindow("distance_on_skeleton");
    w = getWidth();
    h = getHeight();
    
    skeletonValues = newArray(0);
    for (y = 0; y < h; y++) {
        for (x = 0; x < w; x++) {
            val = getPixel(x, y);
            if (val > 0) {
                skeletonValues = Array.concat(skeletonValues, val);
            }
        }
    }
    
    count = skeletonValues.length;
    print("Skeleton pixel count: " + count);
    
    if (count < 10) {
        print("ERROR: Too few skeleton pixels");
        close("skeleton_binary");
        close("distance_temp");
        close("distance_on_skeleton");
        setDefaultArteriolarizationValues();
        return false;
    }
    
    // 統計計算
    Array.getStatistics(skeletonValues, min, max, mean, std);
    
    // グローバル変数に保存
    skeleton_mean = mean;
    skeleton_std = std;
    skeleton_min = min;
    skeleton_max = max;
    
    range = max - min;
    relative_range = range / mean;
 
 // スケルトン上の統計を使用
    if (skeleton_mean > 0) {
         CV_diameter[index] = 100 * skeleton_std / skeleton_mean;
            } else {
                CV_diameter[index] = 0;
            }
 
    // クリーンアップ
    close("skeleton_binary");
    close("distance_temp");
    close("distance_on_skeleton");
    
    MIN_ABSOLUTE_STD_PIXEL = 0.5;
	MIN_RELATIVE_RANGE = 0.50;

	if (std == 0.0) {
    print("=== Decision ===");
    print("INFO: No variation at all (std = 0.0)");
    setDefaultArteriolarizationValues(); // デフォルト値
    return false;
	} else if ((std > 0 && std < MIN_ABSOLUTE_STD_PIXEL) || (relative_range > 0 && relative_range < MIN_RELATIVE_RANGE)) {
    print("=== Decision ===");
    print("INFO: Insufficient variation (but std > 0). Using mode + 1 for threshold.");
    // ヒストグラムから再頻値求める
        maxBin = ceil(max) + 1;
        histogram = newArray(maxBin);
        
        // ヒストグラムを構築
        for (i = 0; i < skeletonValues.length; i++) {
            binIndex = floor(skeletonValues[i]);
            if (binIndex >= 0 && binIndex < maxBin) {
                histogram[binIndex]++;
            }
        }
        
        // 最頻値を検索
        mode_bin = 0;
        max_count = 0;
        for (binIdx = 0; binIdx < maxBin; binIdx++) {
            if (histogram[binIdx] > max_count) {
                max_count = histogram[binIdx];
                mode_bin = binIdx;
            }
        }
    
    skewThreshold = mode_bin + 1;  // 再頻値＋1
    print("INFO: Threshold set to mode + 1 = " + skewThreshold);
	} else {
        print("=== Decision ===");
        print("INFO: Significant variation detected - proceeding with threshold calculation");     
        skewThreshold = mean + 2.0 * std;
	}
	
    // ========================================
    // 画像ベースの高速処理
    // ========================================
    
    // 1. distance - skewThreshold（マイナスは0に）
    selectWindow("distance");
    run("Duplicate...", "title=HighSkewMap");
    run("32-bit");
    run("Subtract...", "value=" + skewThreshold);
    
    // マイナス値を0にする
    setThreshold(0.001, 999999);
    run("Convert to Mask");
    
    // 2. スケルトンマスクでAND
    if (selectWindowSafely("newskeleton1")) {
        selectWindow("newskeleton1");
        run("Duplicate...", "title=skeleton_mask");
        run("Convert to Mask");
        
        imageCalculator("AND create", "HighSkewMap", "skeleton_mask");
        
        if (isOpen("Result of HighSkewMap")) {
            selectWindow("Result of HighSkewMap");
            rename("HighSkew_on_Skeleton");
        }
        
        if (isOpen("HighSkewMap")) {
            selectWindow("HighSkewMap");
            close();
        }
    // 3. 軽度のDilateとSkeletonize
if (selectWindowSafely("HighSkew_on_Skeleton")) {
    selectWindow("HighSkew_on_Skeleton");
    
    w = getWidth();
    h = getHeight();

    var highSkewMask = newArray(w * h);
    ind = 0;
    for (y = 0; y < h; y++) {
        for (x = 0; x < w; x++) {
            val = getPixel(x, y);
            if (val > 0) {
                highSkewMask[ind] = 1;
            } else {
                highSkewMask[ind] = 0;
            }
            ind++;
        }
    }
    
    var distanceArray = newArray(w * h);
    if (selectWindowSafely("distance")) {
        for (y = 0; y < h; y++) {
            for (x = 0; x < w; x++) {
                distanceArray[y * w + x] = getPixel(x, y);
            }
        }
    } else {
        for (i = 0; i < w * h; i++) distanceArray[i] = 3;
    }

    // HighSkew_on_Skeletonに戻る
    if (!selectWindowSafely("HighSkew_on_Skeleton")) {
        print("ERROR: Failed to select HighSkew_on_Skeleton");
        return;
    }
    setColor(255);

    // 膨張処理
    ind = 0;
    for (y = 0; y < h; y++) {
        for (x = 0; x < w; x++) {
            if (highSkewMask[ind] == 1) {
                radius = distanceArray[ind];
                if (radius < 1) radius = 1;
                r = floor(radius);
                yPos = floor(ind / w);
                xPos = ind % w;
                fillOval(xPos - r, yPos - r, 2 * r, 2 * r);
            }
            ind++;
        }
    }
    
    // ★★★ 重要: 描画完了を確実にするため明示的に待機 ★★★
    wait(10);  // ミリ秒単位
    run("Select None");  // 選択範囲をクリア
    
    // ★ Visualization用の画像を先に作成（Gaussian Blurあり）
    if (!selectWindowSafely("HighSkew_on_Skeleton")) {
        print("ERROR: Cannot create visualization - HighSkew_on_Skeleton not found");
        return;
    }
    
    run("Duplicate...", "title=Dilated_HighSkew_for_Visualization");
    
    // 作成確認（リトライ機能付き）
    if (!selectWindowSafely("Dilated_HighSkew_for_Visualization")) {
        print("ERROR: Failed to create Dilated_HighSkew_for_Visualization");
        // 代替処理: 再度作成を試みる
        if (selectWindowSafely("HighSkew_on_Skeleton")) {
            run("Duplicate...", "title=Dilated_HighSkew_for_Visualization");
            if (!selectWindowSafely("Dilated_HighSkew_for_Visualization")) {
                print("CRITICAL ERROR: Cannot create visualization image");
            }
        }
    }
    
    // Gaussian Blurを適用
    if (selectWindowSafely("Dilated_HighSkew_for_Visualization")) {
        run("Gaussian Blur...", "sigma=4");
        print("SUCCESS: Dilated_HighSkew_for_Visualization created and blurred");
    };
    
    // ★ 元の画像でSkeletonize処理（skeleton_maskとAND）
    if (selectWindowSafely("skeleton_mask") && selectWindowSafely("HighSkew_on_Skeleton")) {
        imageCalculator("AND create", "HighSkew_on_Skeleton", "skeleton_mask");
        
        if (isOpen("Result of HighSkew_on_Skeleton")) {
            selectWindow("Result of HighSkew_on_Skeleton");
            rename("skeletonized_HighSkew");
        }
    } else {
        print("WARNING: Cannot create skeletonized version - missing required images");
    }

    // ★ HighSkew_for_Visualization（スケルトンなし）を別途作成
    if (selectWindowSafely("HighSkew_on_Skeleton")) {
        run("Duplicate...", "title=HighSkew_for_Visualization");
        if (selectWindowSafely("HighSkew_for_Visualization")) {
            print("SUCCESS: HighSkew_for_Visualization created");
        }
    }
    
    // ★★★ 最終確認 ★★★
    visualizationCreated = isOpen("Dilated_HighSkew_for_Visualization");
    if (!visualizationCreated) {
        print("FINAL CHECK: Dilated_HighSkew_for_Visualization was NOT created properly");
    } else {
        print("FINAL CHECK: All visualization images successfully created");
    }
    
    // クリーンアップ
    if (isOpen("skeleton_mask")) {
        selectWindow("skeleton_mask");
        close();
    }
    
    if (isOpen("HighSkew_on_Skeleton")) {
        selectWindow("HighSkew_on_Skeleton");
        close();
    }
	

   
	closeResultsWindow();
    if (selectWindowSafely("skeletonized_HighSkew")) {
        selectWindow("skeletonized_HighSkew");
        
        // スケールをリセット（pixel単位で取得）
        run("Set Scale...", "distance=0");
        
        // displayオプションを追加してResultsテーブルにも出力
		run("Analyze Particles...", "size=2-Infinity show=Nothing clear");

        run("Analyze Skeleton (2D/3D)", "prune=none show display");
 
        segmentCount = 0;
        totalBranches = 0;
        totalJunctions = 0;
        totalLength_pixels = 0;
        maxLength_pixels = 0;
        
        // Resultsテーブルから情報を取得
        if (nResults > 0) {
            
            // 各スケルトンの統計を集計
            for (i = 0; i < nResults; i++) {
                numBranches = getResult("# Branches", i);
                numJunctions = getResult("# Junctions", i);
                avgBranchLength = getResult("Average Branch Length", i);
                maxBranchLength = getResult("Maximum Branch Length", i);
                
                totalBranches = totalBranches + numBranches;
                totalJunctions = totalJunctions + numJunctions;
                
                // 総長さの計算：ブランチ数 × 平均長さ
                skeletonLength = numBranches * avgBranchLength;
                totalLength_pixels = totalLength_pixels + skeletonLength;
                
                if (maxBranchLength > maxLength_pixels) {
                    maxLength_pixels = maxBranchLength;
                }
                
            }
            
            segmentCount = totalBranches;
            
            // μm単位に変換
            totalLength_um = totalLength_pixels * pixel_size_um;
            maxLength_um = maxLength_pixels * pixel_size_um;
                        
            if (segmentCount > 0) {
                // mm単位に変換して保存
                arteriolarization_segment_count[index] = segmentCount;
                arteriolarization_total_length[index] = totalLength_um / 1000.0;
                arteriolarization_max_segment_length[index] = maxLength_um / 1000.0;
                
                if (MNV_Areas[index] > 0) {
                    arteriolarization_density[index] = segmentCount / MNV_Areas[index];
                    highSkewPercentage [index] = arteriolarization_total_length[index]  / vessel_Lengths[index];
                } else {
                    arteriolarization_density[index] = 0;
                }
                
                arteriolarization_connectivity_index[index] = (totalLength_um / 1000.0) / segmentCount;
                
                // 局所変動の計算（簡易版：各スケルトンの平均長さのCV）
                if (nResults > 1) {
                    avgLengths = newArray(nResults);
                    for (i = 0; i < nResults; i++) {
                        avgLengths[i] = getResult("Average Branch Length", i) * pixel_size_um;
                    }
                    Array.getStatistics(avgLengths, minL, maxL, meanL, stdL);
                    if (meanL > 0) {
                        localized_diameter_variation[index] = 100 * stdL / meanL;
                    } else {
                        localized_diameter_variation[index] = 0;
                    }
                } else {
                    localized_diameter_variation[index] = 0;
                }
                               
            } else {
                print("No segments detected");
                setDefaultArteriolarizationValues();
            }
            
        } else {
            print("ERROR: Results table is empty");
            setDefaultArteriolarizationValues();
        }
        
        // クリーンアップ
        if (isOpen("Branch information")) {
            selectWindow("Branch information");
            run("Close");
        }
        
        if (isOpen("Tagged skeleton")) {
            selectWindow("Tagged skeleton");
            close();
        }
        
        close("skeletonized_HighSkew");
        closeResultsWindow();
    }
    
    print("=== 細動脈化セグメント解析完了 ===");
    // グローバル変数として保存
    global_skewThreshold = skewThreshold;

    // ========================================
    // 空間分布解析を追加実行
    // ========================================
    analyzeSpatialDistribution();
    classifyMNVbyLoopsDetailed();
    return true;

}

function createVisualizationRGB() {
    print("Creating visualization RGB image");

    if (!selectWindowSafely("binary.tif")) {
        print("Warning: binary.tif not found for visualization");
        return;
    }
    run("Create Selection");
    run("Enlarge...", "enlarge=-1");

    if (!selectWindowSafely("crop_reference.tif")) {
        print("Warning: crop_reference.tif not found for visualization");
        return;
    }

    getStatistics(MNVarea, MNVmean, MNVmin, MNVmax, MNVstd, MNVhistogram);

	// 画像がアクティブな状態で実行
	// run("Histogram");  // ヒストグラムウィンドウを開く

	// ヒストグラムウィンドウをアクティブにする
	//selectWindow(getTitle()); 
	//saveStageImproved(s_output, file, "", "MNV_histogram");


     if (MNVmax > 0) {
        mean_intensity[index] = MNVmean / MNVmax;
        MNV_max_mean_ratio[index] = (MNVmax - MNVmean) / MNVstd;
        standard_deviation[index] = 100 * MNVstd / MNVmean;
        vessel_density_index[index] = vessel_densities[index] * mean_intensity[index] * 100;
        immature_vessel_area_index[index] = (1 - vessel_density_index[index] / 100) * vessel_Areas[index];
    }
/// for colorization of the original image
    if (!selectWindowSafely("crop_reference.tif")) {
        print("Warning: crop_reference.tif not found for visualization");
        return;
    }
    run("RGB Color");
    run("Split Channels");
    imageCalculator("Subtract create", "crop_reference.tif (blue)", "binary.tif");
    if (selectWindowSafely("Dilated_HighSkew_for_Visualization")) {
    imageCalculator("Subtract create", "crop_reference.tif (green)", "Dilated_HighSkew_for_Visualization");
} else {
    print("ERROR: Dilated_HighSkew_for_Visualization not found after retries");
    print("Creating emergency black mask for visualization");
    newImage("Dilated_HighSkew_for_Visualization", "8-bit black", imageWidth, imageHeight, 1);
    imageCalculator("Subtract create", "crop_reference.tif (green)", "Dilated_HighSkew_for_Visualization");
}

        run("Merge Channels...", "c1=[crop_reference.tif (red)] c2=[Result of crop_reference.tif (green)] c3=[Result of crop_reference.tif (blue)]");

        if (isOpen("RGB")) {
            selectWindow("RGB");
            rename("Visualization_RGB");
    	// 視覚化（Visualization_RGBが作成された後）
    	if (selectWindowSafely("Visualization_RGB")) {
        	visualizeArteriolarizationSegments(s_output, file);
    	}
            parameters = "Area: " + d2s(vessel_Areas[index], 2);
            saveStageImproved(s_output, file, parameters, "MNV_");

            print("Visualization RGB image created successfully");
        }
/// for colorization of the binalized MNV image        

    if (!selectWindowSafely("distance")) {
        print("Warning: binary.tif not found for visualization");
        return;
    }
    safeRoiClose();
    run("Remove Overlay");
   	run("Duplicate...", "title=working ignore");
   	run("Select None");
    run("Enhance Contrast...", "saturated=0.35");
	run("RGB Color");
	rename("working.tif");
	run("Split Channels");
    if (selectWindowSafely("Dilated_HighSkew_for_Visualization")) {
    imageCalculator("Subtract create", "working.tif (green)", "Dilated_HighSkew_for_Visualization");
} else {
    print("ERROR: Dilated_HighSkew_for_Visualization not found for second calculation");
    print("Creating emergency black mask");
    if (!isOpen("Dilated_HighSkew_for_Visualization")) {
        newImage("Dilated_HighSkew_for_Visualization", "8-bit black", imageWidth, imageHeight, 1);
    }
    imageCalculator("Subtract create", "working.tif (green)", "Dilated_HighSkew_for_Visualization");
}
        run("Merge Channels...", "c1=[working.tif (red)] c2=[Result of working.tif (green)]");

	outputPath = s_output + File.separator + "Color_coded_" + file;
    saveAs("jpg", outputPath);

}

// ========================================
// 空間分布解析
// ========================================

function analyzeSpatialDistribution() {
    if (!selectWindowSafely("HighSkew_for_Visualization")) {
        print("Warning: distance map not available for spatial analysis");
        setDefaultSpatialValues();
        return false;
    }
    if (!selectWindowSafely("distance")) {
        print("Warning: distance map not available for spatial analysis");
        setDefaultSpatialValues();
        return false;
    }
    selectWindow("Dilated_HighSkew_for_Visualization");        
    run("Duplicate...", "title=ThickMap");
    run("Convert to Mask");
    
    // MNV領域の中心座標を取得
    selectWindow("distance");
    w = getWidth();
    h = getHeight();
    
    // MNV領域描画
    makeSelection("freehand", saved_MNV_xCoords, saved_MNV_yCoords);
    roiManager("add");
    roiManager("Select", roiManager("count") - 1);
    getSelectionBounds(x, y, width, height);
    centerX = x + width / 2;
    centerY = y + height / 2;
    
    if (DEBUG) {  
        print("DEBUG: MNV center = (" + centerX + ", " + centerY + ")");
    }
    
    // ========================================
    // 1. 既存の中心部と周辺部の血管径比較
    // ========================================
    run("Set Scale...", "distance=0");   
    roiManager("Select", roiManager("count") - 1);
    getStatistics(roiArea);
    estimatedRadius = sqrt(roiArea / PI);
    centerRadius = estimatedRadius / 3;
    
    shrinkPixels = (estimatedRadius - centerRadius);
    if (DEBUG) {
        print("DEBUG: MNV Area = " + d2s(roiArea, 1) + " pixels");
        print("DEBUG: Estimated Radius = " + d2s(estimatedRadius, 2) + " pixels");
        print("DEBUG: Center Radius = " + d2s(centerRadius, 2) + " pixels");
        print("DEBUG: Shrink Pixels = " + d2s(shrinkPixels, 2) + " pixels");
    }
    
    outerIndex = roiManager("count") - 1;
    roiManager("Select", outerIndex);
    run("Enlarge...", "enlarge=" + (-shrinkPixels));
    roiManager("add");
    innerIndex = roiManager("count") - 1;
    
    if (DEBUG) {
        getSelectionBounds(x2, y2, width2, height2);
        getStatistics(roiArea);
        print("DEBUG: Scaled ROI bounds = (" + x2 + ", " + y2 + ", " + width2 + ", " + height2 + ")");
        print("DEBUG: Scaled ROI area = " + d2s(roiArea, 1) + " pixels");
    }
    
    // 統計処理（中心部）
    selectWindow("distance");
    roiManager("Select", innerIndex);
    getStatistics(area, centerMean, centerMin, centerMax, centerStd);
    
    selectWindow("ThickMap");
    roiManager("Select", innerIndex);
    getStatistics(area, mean);
    thick_vessel_center_ratio[index] = mean / 255 * 100;
    
    // リング領域（周辺部）
    roiManager("Select", newArray(outerIndex, innerIndex));
    roiManager("XOR");
    roiManager("add");
    ringIndex = roiManager("count") - 1;
    
    selectWindow("distance");
    roiManager("Select", ringIndex);
    getStatistics(area, peripheryMean, peripheryMin, peripheryMax, peripheryStd);
    
    selectWindow("ThickMap");
    roiManager("Select", ringIndex);
    getStatistics(area, mean);
    thick_vessel_periphery_ratio[index] = mean / 255 * 100;
    
    diameter_center_mean[index] = centerMean * 2 * mm_per_pixcel * 1000;
    diameter_periphery_mean[index] = peripheryMean * 2 * mm_per_pixcel * 1000;
    
    if (peripheryMean > 0) {
        diameter_center_periphery_ratio[index] = centerMean / peripheryMean;
    } else {
        diameter_center_periphery_ratio[index] = 1.0;
    }
    
	// ========================================
    // 2. Trunk Vessel Eccentricity 測定
    // ========================================
    
    // 太い血管（trunk vessel）のみを抽出
    selectWindow("ThickMap");
    run("Duplicate...", "title=TrunkOnly");
    
    // スケルトン化して血管の中心線を取得
    run("Skeletonize");
    
    // 主幹血管のピクセル座標を直接取得
    run("Create Selection");
    getSelectionCoordinates(xCoords, yCoords);
    nPixels = xCoords.length;
    
    if (DEBUG) {
        print("DEBUG: Number of trunk vessel pixels detected = " + nPixels);
    }
    
    // 最小ピクセル数のチェック（小さすぎるROIの処理）
    minPixelsRequired = 50;
    
    // 小さなROIの場合、より緩い基準を適用
    if (estimatedRadius < 20) {
        minPixelsRequired = 20;  // 小型ROI用の閾値
        if (DEBUG) {
            print("DEBUG: Small ROI detected (radius=" + d2s(estimatedRadius, 1) + "), using relaxed threshold");
        }
    }
    
    if (nPixels < minPixelsRequired) {
        print("Warning: Insufficient trunk vessel pixels (" + nPixels + " < " + minPixelsRequired + ")");
        trunk_eccentricity[index] = -1;
        angular_distribution_cv[index] = -1;
        close("TrunkOnly");
        close("ThickMap");
        run("Select None");
        return false;
    }
    
    // ========================================
    // 中心部と周辺部のピクセルを分類
    // ========================================
    
    // まず各領域のピクセル数をカウント
    centerCount = 0;
    peripheryCount = 0;
    
    // 小型ROIの場合、中心領域を調整
    effectiveCenterRadius = centerRadius;
    if (estimatedRadius < 20) {
        // 非常に小さいROIの場合、中心領域を全体の40%に設定
        effectiveCenterRadius = estimatedRadius * 0.4;
        if (DEBUG) {
            print("DEBUG: Adjusted center radius from " + d2s(centerRadius, 1) + " to " + d2s(effectiveCenterRadius, 1));
        }
    }
    
    for (i = 0; i < nPixels; i++) {
        px = xCoords[i];
        py = yCoords[i];
        
        distFromCenter = sqrt((px - centerX) * (px - centerX) + 
                             (py - centerY) * (py - centerY));
        
        if (distFromCenter <= effectiveCenterRadius) {
            centerCount++;
        } else if (distFromCenter <= estimatedRadius) {
            peripheryCount++;
        }
    }
    
    // 配列を事前に確保
    centerPixelsList_X = newArray(centerCount);
    centerPixelsList_Y = newArray(centerCount);
    peripheryPixelsList_X = newArray(peripheryCount);
    peripheryPixelsList_Y = newArray(peripheryCount);
    
    // 配列に格納
    centerIdx = 0;
    peripheryIdx = 0;
    
    for (i = 0; i < nPixels; i++) {
        px = xCoords[i];
        py = yCoords[i];
        
        distFromCenter = sqrt((px - centerX) * (px - centerX) + 
                             (py - centerY) * (py - centerY));
        
        if (distFromCenter <= effectiveCenterRadius) {
            centerPixelsList_X[centerIdx] = px;
            centerPixelsList_Y[centerIdx] = py;
            centerIdx++;
        } else if (distFromCenter <= estimatedRadius) {
            peripheryPixelsList_X[peripheryIdx] = px;
            peripheryPixelsList_Y[peripheryIdx] = py;
            peripheryIdx++;
        }
    }
    
    if (DEBUG) {
        print("DEBUG: Center pixels = " + centerCount);
        print("DEBUG: Periphery pixels = " + peripheryCount);
    }
    
    // ========================================
    // A. 全体のEccentricityとAngular Distribution
    // ========================================
    
    trunkCenterX = 0;
    trunkCenterY = 0;
    
    for (i = 0; i < nPixels; i++) {
        trunkCenterX += xCoords[i];
        trunkCenterY += yCoords[i];
    }
    
    trunkCenterX /= nPixels;
    trunkCenterY /= nPixels;
    
    eccentricityDistance = sqrt((trunkCenterX - centerX) * (trunkCenterX - centerX) + 
                                (trunkCenterY - centerY) * (trunkCenterY - centerY));
    
    // 正規化（0-1の範囲に制限）
    trunk_eccentricity[index] = eccentricityDistance / estimatedRadius;
    if (trunk_eccentricity[index] > 1.0) {
        trunk_eccentricity[index] = 1.0;  // 上限を1.0に設定
    }
    if (trunk_eccentricity[index] < 0) {
        trunk_eccentricity[index] = 0;  // 下限を0に設定
    }
    
    // 全体の角度分布
    sectors = 8;
    sectorCounts_all = newArray(sectors);
    
    for (i = 0; i < nPixels; i++) {
        dx = xCoords[i] - centerX;
        dy = yCoords[i] - centerY;
        
        angle = atan2(dy, dx) * 180 / PI;
        if (angle < 0) angle += 360;
        
        sectorIdx = floor(angle / (360 / sectors));
        if (sectorIdx >= sectors) sectorIdx = sectors - 1;
        sectorCounts_all[sectorIdx]++;
    }
    
    angular_distribution_cv[index] = calculateAngularCV(sectorCounts_all, sectors);
    
    // 小型ROIでAngular CVが計算できない場合の代替処理
    if (angular_distribution_cv[index] < 0 && nPixels >= 10) {
        // より粗いセクタ数（4分割）で再計算
        sectors_coarse = 4;
        sectorCounts_coarse = newArray(sectors_coarse);
        
        for (i = 0; i < nPixels; i++) {
            dx = xCoords[i] - centerX;
            dy = yCoords[i] - centerY;
            
            angle = atan2(dy, dx) * 180 / PI;
            if (angle < 0) angle += 360;
            
            sectorIdx = floor(angle / (360 / sectors_coarse));
            if (sectorIdx >= sectors_coarse) sectorIdx = sectors_coarse - 1;
            sectorCounts_coarse[sectorIdx]++;
        }
        
        angular_distribution_cv[index] = calculateAngularCV(sectorCounts_coarse, sectors_coarse);
        
        if (DEBUG && angular_distribution_cv[index] >= 0) {
            print("DEBUG: Using coarse sector analysis (4 sectors) for small ROI");
        }
    }
    
    // 新指標: 放射状均一性指数（ローカル変数）
    radial_uniformity = calculateRadialUniformity(sectorCounts_all, sectors);
    
    // ========================================
    // B. 中心部のみの解析（ローカル変数）
    // ========================================
    
    trunk_ecc_center = -1;
    angular_cv_center = -1;
    
    if (centerCount >= 10) {
        centerTrunkX = 0;
        centerTrunkY = 0;
        
        for (i = 0; i < centerCount; i++) {
            centerTrunkX += centerPixelsList_X[i];
            centerTrunkY += centerPixelsList_Y[i];
        }
        
        centerTrunkX /= centerCount;
        centerTrunkY /= centerCount;
        
        centerEccDist = sqrt((centerTrunkX - centerX) * (centerTrunkX - centerX) + 
                            (centerTrunkY - centerY) * (centerTrunkY - centerY));
        
        trunk_ecc_center = centerEccDist / effectiveCenterRadius;
        if (trunk_ecc_center > 1.0) trunk_ecc_center = 1.0;
        if (trunk_ecc_center < 0) trunk_ecc_center = 0;
        
        sectorCounts_center = newArray(sectors);
        
        for (i = 0; i < centerCount; i++) {
            dx = centerPixelsList_X[i] - centerX;
            dy = centerPixelsList_Y[i] - centerY;
            
            angle = atan2(dy, dx) * 180 / PI;
            if (angle < 0) angle += 360;
            
            sectorIdx = floor(angle / (360 / sectors));
            if (sectorIdx >= sectors) sectorIdx = sectors - 1;
            sectorCounts_center[sectorIdx]++;
        }
        
        angular_cv_center = calculateAngularCV(sectorCounts_center, sectors);
    }
    
    // ========================================
    // C. 周辺部のみの解析（ローカル変数）
    // ========================================
    
    trunk_ecc_periphery = -1;
    angular_cv_periphery = -1;
    
    if (peripheryCount >= 10) {
        peripheryTrunkX = 0;
        peripheryTrunkY = 0;
        
        for (i = 0; i < peripheryCount; i++) {
            peripheryTrunkX += peripheryPixelsList_X[i];
            peripheryTrunkY += peripheryPixelsList_Y[i];
        }
        
        peripheryTrunkX /= peripheryCount;
        peripheryTrunkY /= peripheryCount;
        
        peripheryEccDist = sqrt((peripheryTrunkX - centerX) * (peripheryTrunkX - centerX) + 
                               (peripheryTrunkY - centerY) * (peripheryTrunkY - centerY));
        
        ringRadius = estimatedRadius - effectiveCenterRadius;
        if (ringRadius > 0) {
            trunk_ecc_periphery = (peripheryEccDist - effectiveCenterRadius) / ringRadius;
            if (trunk_ecc_periphery > 1.0) trunk_ecc_periphery = 1.0;
            if (trunk_ecc_periphery < 0) trunk_ecc_periphery = 0;
        } else {
            trunk_ecc_periphery = 0;
        }
        
        sectorCounts_periphery = newArray(sectors);
        
        for (i = 0; i < peripheryCount; i++) {
            dx = peripheryPixelsList_X[i] - centerX;
            dy = peripheryPixelsList_Y[i] - centerY;
            
            angle = atan2(dy, dx) * 180 / PI;
            if (angle < 0) angle += 360;
            
            sectorIdx = floor(angle / (360 / sectors));
            if (sectorIdx >= sectors) sectorIdx = sectors - 1;
            sectorCounts_periphery[sectorIdx]++;
        }
        
        angular_cv_periphery = calculateAngularCV(sectorCounts_periphery, sectors);
    }
    
    // ========================================
    // 4. 文献準拠型分類システム（ローカル変数で処理）
    // ========================================
    
    print("");
    print("=== Trunk Vessel Distribution Analysis ===");
    print("--- ROI Information ---");
    print("MNV estimated radius = " + d2s(estimatedRadius, 1) + " pixels");
    print("Effective center radius = " + d2s(effectiveCenterRadius, 1) + " pixels");
    if (estimatedRadius < 20) {
        print("NOTE: Small ROI detected - using adapted analysis parameters");
    }
    print("");
    print("--- Overall Metrics ---");
    print("Total trunk pixels = " + nPixels);
    print("Trunk vessel eccentricity (all) = " + d2s(trunk_eccentricity[index], 3) + " (0-1 scale)");
    if (angular_distribution_cv[index] >= 0) {
        print("Angular distribution CV (all) = " + d2s(angular_distribution_cv[index], 3));
    } else {
        print("Angular distribution CV (all) = N/A (insufficient sectors)");
    }
    print("Radial uniformity index = " + d2s(radial_uniformity, 3) + " (0=directional, 1=omnidirectional)");
    
    print("");
    print("--- Center Region Metrics ---");
    if (trunk_ecc_center >= 0) {
        print("Center pixels = " + centerCount);
        print("Trunk eccentricity (center) = " + d2s(trunk_ecc_center, 3));
        print("Angular CV (center) = " + d2s(angular_cv_center, 3));
    } else {
        print("Insufficient center pixels for analysis");
    }
    
    print("");
    print("--- Periphery Region Metrics ---");
    if (trunk_ecc_periphery >= 0) {
        print("Periphery pixels = " + peripheryCount);
        print("Trunk eccentricity (periphery) = " + d2s(trunk_ecc_periphery, 3));
        print("Angular CV (periphery) = " + d2s(angular_cv_periphery, 3));
    } else {
        print("Insufficient periphery pixels for analysis");
    }
    
    print("");
    print("--- Vessel Diameter Metrics ---");
    print("Center/Periphery diameter ratio = " + d2s(diameter_center_periphery_ratio[index], 3));
    print("Thick vessel center ratio = " + d2s(thick_vessel_center_ratio[index], 2) + "%");
    print("Thick vessel periphery ratio = " + d2s(thick_vessel_periphery_ratio[index], 2) + "%");
    
    // ========================================
    // 文献準拠型 Medusa vs Seafan 判定
    // ========================================
    
//	print("\\Clear");
    print("=== Pattern Classification ===");
    
    // 階層的判定システム（文献的根拠に基づく優先順位）
    
    // TIER 1: 決定的指標（文献で最重要とされる）
    // 全体的なEccentricity - 重み: 40%
    tier1_score = 0;
    tier1_max = 40;
    
    // 小型ROIでEccentricity=1.0の場合、信頼性が低い可能性を考慮
    if (estimatedRadius < 20 && trunk_eccentricity[index] >= 0.95) {
        // 非常に小さいROIで最大偏心の場合、中程度の評価
        tier1_score = 30;
        tier1_interpretation = "Eccentric distribution (small ROI, moderate confidence)";
    } else if (trunk_eccentricity[index] < 0.20) {
        tier1_score = 0;  // 強いMedusa指標
        tier1_interpretation = "Strong central distribution (Medusa)";
    } else if (trunk_eccentricity[index] < 0.35) {
        tier1_score = 15;  // 弱いMedusa傾向
        tier1_interpretation = "Moderate central tendency";
    } else if (trunk_eccentricity[index] < 0.50) {
        tier1_score = 25;  // 弱いSeafan傾向
        tier1_interpretation = "Moderate eccentric tendency";
    } else {
        tier1_score = 40;  // 強いSeafan指標
        tier1_interpretation = "Strong eccentric distribution (Seafan)";
    }
    
    // TIER 2: 重要指標（文献で重要性が確認されている）
    // 放射状均一性 - 重み: 30%
    tier2_score = 0;
    tier2_max = 30;
    
    // Angular CVが無効な場合はRadial Uniformityのみで判定
    if (angular_distribution_cv[index] < 0) {
        // Angular CVが計算不可能な場合
        if (radial_uniformity >= 0) {
            if (radial_uniformity > 0.50) {
                tier2_score = 5;  // 多方向の可能性
                tier2_interpretation = "Multiple sectors occupied (likely multidirectional)";
            } else {
                tier2_score = 25;  // 一方向の可能性
                tier2_interpretation = "Few sectors occupied (likely unidirectional)";
            }
        } else {
            tier2_score = 15;  // 不明
            tier2_interpretation = "Unable to determine directionality (insufficient data)";
        }
    } else {
        // Angular CVが有効な場合は通常の判定
        if (radial_uniformity >= 0) {
            if (radial_uniformity > 0.75) {
                tier2_score = 0;  // 全方向均一（Medusa）
                tier2_interpretation = "Omnidirectional radiation (Medusa)";
            } else if (radial_uniformity > 0.60) {
                tier2_score = 10;
                tier2_interpretation = "Predominantly multidirectional";
            } else if (radial_uniformity > 0.40) {
                tier2_score = 20;
                tier2_interpretation = "Predominantly unidirectional";
            } else {
                tier2_score = 30;  // 一方向性（Seafan）
                tier2_interpretation = "Unidirectional radiation (Seafan)";
            }
        } else {
            tier2_score = 15;  // 中間値
            tier2_interpretation = "Unable to determine directionality";
        }
    }
    
    // TIER 3: 補助指標（追加情報として有用）
    // 中心部血管密度 - 重み: 20%
    tier3_score = 0;
    tier3_max = 20;
    
    if (thick_vessel_center_ratio[index] > 15) {
        tier3_score = 0;  // 中心部密（Medusa）
        tier3_interpretation = "Dense central vessels (Medusa)";
    } else if (thick_vessel_center_ratio[index] > 10) {
        tier3_score = 7;
        tier3_interpretation = "Moderate central vessel density";
    } else if (thick_vessel_center_ratio[index] > 5) {
        tier3_score = 13;
        tier3_interpretation = "Sparse central vessels";
    } else {
        tier3_score = 20;  // 中心部疎（Seafan）
        tier3_interpretation = "Very sparse central vessels (Seafan)";
    }
    
    // TIER 4: 参考指標（ROIサイズに依存しやすい）
    // 中心/周辺径比 - 重み: 10%
    tier4_score = 0;
    tier4_max = 10;
    
    if (diameter_center_periphery_ratio[index] > 1.4) {
        tier4_score = 0;  // 中心優位（Medusa）
        tier4_interpretation = "Central vessel dominance";
    } else if (diameter_center_periphery_ratio[index] > 1.2) {
        tier4_score = 3;
        tier4_interpretation = "Moderate central dominance";
    } else if (diameter_center_periphery_ratio[index] > 1.0) {
        tier4_score = 7;
        tier4_interpretation = "Balanced vessel distribution";
    } else {
        tier4_score = 10;  // 周辺優位（Seafan）
        tier4_interpretation = "Peripheral vessel dominance";
    }
    
    // 総合スコア計算（0-100点）
    totalScore = tier1_score + tier2_score + tier3_score + tier4_score;
    maxScore = tier1_max + tier2_max + tier3_max + tier4_max;
    
    // 信頼度の計算（小さいROIでは信頼度を下げる）
    confidence = "HIGH";
    confidenceNote = "";
    if (nPixels < 100) {
        confidence = "LOW";
        confidenceNote = " (Limited vessel pixels may affect accuracy)";
    } else if (nPixels < 200) {
        confidence = "MODERATE";
        confidenceNote = " (Moderate vessel density)";
    }
    
    print("Classification Score: " + d2s(totalScore, 1) + " / " + maxScore);
    print("Confidence Level: " + confidence + confidenceNote);
    
    // Angular CVが無効な場合の警告
    if (angular_distribution_cv[index] < 0) {
        print("NOTE: Angular distribution analysis limited by small vessel count");
        print("      Classification relies more heavily on eccentricity and density metrics");
    }
    
	if (DEBUG)    print("");
	if (DEBUG)    print("Scoring Breakdown:");
	if (DEBUG)    print("  TIER 1 (Eccentricity, 40%): " + d2s(tier1_score, 1) + " / " + tier1_max);
	if (DEBUG)    print("    -> " + tier1_interpretation);
	if (DEBUG)    print("  TIER 2 (Radial Uniformity, 30%): " + d2s(tier2_score, 1) + " / " + tier2_max);
	if (DEBUG)    print("    -> " + tier2_interpretation);
	if (DEBUG)    print("  TIER 3 (Central Density, 20%): " + d2s(tier3_score, 1) + " / " + tier3_max);
	if (DEBUG)    print("    -> " + tier3_interpretation);
	if (DEBUG)    print("  TIER 4 (Diameter Ratio, 10%): " + d2s(tier4_score, 1) + " / " + tier4_max);
	if (DEBUG)    print("    -> " + tier4_interpretation);
	if (DEBUG)    print("");
    
    // 最終判定（文献準拠閾値）
    // Medusa: 0-30点、Intermediate: 30-60点、Seafan: 60-100点
    patternClassification = "";
    if (totalScore < 30) {
        print(">>> CLASSIFICATION: MEDUSA Pattern <<<");
        print("Characteristics: Central feeder vessel with omnidirectional radiation");
        patternClassification = "MEDUSA";
    } else if (totalScore < 60) {
        print(">>> CLASSIFICATION: INTERMEDIATE Pattern <<<");
        print("Characteristics: Mixed features, uncertain dominant pattern");
        if (totalScore < 45) {
            print("Tendency: Leaning toward Medusa");
        } else {
            print("Tendency: Leaning toward Seafan");
        }
        patternClassification = "INTERMEDIATE";
    } else {
        print(">>> CLASSIFICATION: SEAFAN Pattern <<<");
        print("Characteristics: Eccentric feeder vessel with unidirectional radiation");
        patternClassification = "SEAFAN";
    }
    
    print("Final Classification: " + patternClassification + " (Score: " + d2s(totalScore, 1) + ", Confidence: " + confidence + ")");
    
    close("TrunkOnly");
    close("ThickMap");
    run("Select None");

 	/// branch information
 
	aggregateBranchInfoByRegion(innerIndex, ringIndex);
    
    // ========================================
    // 2. 放射状血管径プロファイル
    // ========================================
    
 	NUM_RADIAL_BINS = 10;
    maxRadiusPixels = estimatedRadius;
    binWidth = maxRadiusPixels / NUM_RADIAL_BINS;
    
    radialMeans = newArray(NUM_RADIAL_BINS);
    
    selectWindow("distance");
       // ROI Managerから最後のROI（MNV領域）を取得
        makeSelection("freehand", saved_MNV_xCoords, saved_MNV_yCoords);
    	roiManager("add");
        roiManager("Select", roiManager("count") - 1);
        originalROIIndex = roiManager("count") - 1;
        
 for (bin = 0; bin < NUM_RADIAL_BINS; bin++) {
    innerR = bin * binWidth;
    outerR = (bin + 1) * binWidth;
    
    if (bin == 0) {
        roiManager("Select", originalROIIndex);
        run("Enlarge...", "enlarge=" + (-outerR));
        selectWindow("distance");
        getStatistics(area, mean);
        radialMeans[bin] = mean * 2 * mm_per_pixcel * 1000; // μm単位
    } else {
        // 外側ROI
        roiManager("Select", originalROIIndex);
        run("Enlarge...", "enlarge=" + (-outerR));
        roiManager("Add");
        outerIdx = roiManager("count") - 1;

        // 内側ROI
        roiManager("Select", originalROIIndex);
        run("Enlarge...", "enlarge=" + (-innerR));
        roiManager("Add");
        innerIdx = roiManager("count") - 1;

        // XOR: ドーナツ型ROIを生成
        roiManager("Select", newArray(outerIdx, innerIdx));
        roiManager("XOR");
        ringIdx = roiManager("count") - 1;

        // ドーナツ型ROIの統計取得
        roiManager("Select", ringIdx);
        selectWindow("distance");
        getStatistics(area, mean);
        radialMeans[bin] = mean * 2 * mm_per_pixcel * 1000; // μm単位

    }
    
            print("Bin " + bin + " (R=" + d2s(innerR, 1) + "-" + d2s(outerR, 1) + " px): " + d2s(radialMeans[bin], 2) + " μm");

    }
    
    // 放射状勾配を計算（線形回帰の傾き）
    sumX = 0;
    sumY = 0;
    sumXY = 0;
    sumX2 = 0;
    n = NUM_RADIAL_BINS;
    
    for (i = 0; i < n; i++) {
        x = i; // ビン番号
        y = radialMeans[i];
        sumX += x;
        sumY += y;
        sumXY += x * y;
        sumX2 += x * x;
    }
    
    slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
    diameter_radial_gradient[index] = slope;
    
    if (DEBUG) {
        print("DEBUG: Radial gradient = " + d2s(slope, 3) + " μm/bin");
        print("Radial profile: " + arrayToString(radialMeans));
    }
	safeRoiClose();
	stability_score[index] = calculateMetrics(radialMeans);


    print("=== 血管径空間分布解析完了 ===");
    return true;
}

// ========================================
// ヘルパー関数: Angular CVの計算
// ========================================
function calculateAngularCV(sectorCounts, sectors) {
    nonZeroSectors = 0;
    sumCounts = 0;
    
    for (i = 0; i < sectors; i++) {
        if (sectorCounts[i] > 0) {
            nonZeroSectors++;
            sumCounts += sectorCounts[i];
        }
    }
    
    // 最低セクタ数の要件を動的に調整
    minSectors = 2;
    if (sectors >= 8) {
        minSectors = 3;
    }
    
    if (nonZeroSectors < minSectors) {
        return -1;
    }
    
    meanCount = sumCounts / nonZeroSectors;
    
    variance = 0;
    for (i = 0; i < sectors; i++) {
        if (sectorCounts[i] > 0) {
            diff = sectorCounts[i] - meanCount;
            variance += diff * diff;
        }
    }
    variance /= nonZeroSectors;
    stdDev = sqrt(variance);
    
    cv = stdDev / meanCount;
    
    if (cv > 2.0) {
        cv = 2.0;
    }
    
    return cv;
}

// ========================================
// ヘルパー関数: 放射状均一性指数の計算
// ========================================
function calculateRadialUniformity(sectorCounts, sectors) {
    // 血管が存在するセクタ数をカウント
    occupiedSectors = 0;
    for (i = 0; i < sectors; i++) {
        if (sectorCounts[i] > 0) {
            occupiedSectors++;
        }
    }
    
    if (occupiedSectors < 3) {
        return 0;  // 2セクタ以下は方向性あり
    }
    
    // 均一性 = 占有セクタ数 / 全セクタ数
    uniformity = occupiedSectors / sectors;
    
    // セクタ間の分布均一性も考慮
    if (occupiedSectors >= 3) {
        sumCounts = 0;
        for (i = 0; i < sectors; i++) {
            if (sectorCounts[i] > 0) {
                sumCounts += sectorCounts[i];
            }
        }
        meanCount = sumCounts / occupiedSectors;
        
        // 変動係数を計算
        variance = 0;
        for (i = 0; i < sectors; i++) {
            if (sectorCounts[i] > 0) {
                diff = sectorCounts[i] - meanCount;
                variance += diff * diff;
            }
        }
        variance /= occupiedSectors;
        stdDev = sqrt(variance);
        cv = stdDev / meanCount;
        
        // CVが低いほど均一（0.5以下なら均一とみなす）
        if (cv < 0.5) {
            distributionUniformity = 1.0;
        } else if (cv < 1.0) {
            distributionUniformity = 0.7;
        } else {
            distributionUniformity = 0.4;
        }
        
        // 最終的な均一性 = セクタ占有率 × 分布均一性
        uniformity = uniformity * distributionUniformity;
    }
    
    return uniformity;
}

// ===========================================
// 汎用解析関数
// ===========================================
function calculateMetrics(diameters) {
    n = lengthOf(diameters);

    // ---- 平均・分散・SD・CV ----
    sum = 0;
    for (i=0; i<n; i++)
        sum += diameters[i];
    mean = sum / n;

    varSum = 0;
    for (i=0; i<n; i++)
        varSum += pow(diameters[i] - mean, 2);
    variance = varSum / n;
    sd = sqrt(variance);
    cv = (sd / mean) * 100;

    // ---- 隣接変化率 ----
    adjacentChanges = newArray(n-1);
    for (i=0; i<n-1; i++)
        adjacentChanges[i] = abs(diameters[i+1] - diameters[i]) / diameters[i] * 100;

    sumAdj = 0;
    for (i=0; i<lengthOf(adjacentChanges); i++)
        sumAdj += adjacentChanges[i];
    meanAdjacentChange = sumAdj / lengthOf(adjacentChanges);

    // ---- 逆行性変化 ----
    reversalCount = 0;
    maxReversalMagnitude = 0;
    for (i=0; i<n-1; i++) {
        if (diameters[i+1] < diameters[i]) {
            reversalCount++;
            magnitude = (diameters[i] - diameters[i+1]) / diameters[i] * 100;
            if (magnitude > maxReversalMagnitude)
                maxReversalMagnitude = magnitude;
        }
    }

    // ---- 線形回帰 ----
    sumX = 0; sumY = 0; sumXY = 0; sumX2 = 0;
    for (i=0; i<n; i++) {
        sumX += i;
        sumY += diameters[i];
        sumXY += i * diameters[i];
        sumX2 += i * i;
    }
    slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
    intercept = (sumY - slope * sumX) / n;

    residuals = newArray(n);
    resSum = 0;
    for (i=0; i<n; i++) {
        predicted = slope * i + intercept;
        residuals[i] = diameters[i] - predicted;
        resSum += pow(residuals[i], 2);
    }
    residualSD = sqrt(resSum / n);
    residualCV = (residualSD / mean) * 100;

    // ---- 範囲 ----
	minDiameter = diameters[0];
	maxDiameter = diameters[0];
	for (i=1; i<n; i++) {
    if (diameters[i] < minDiameter)
        minDiameter = diameters[i];
    if (diameters[i] > maxDiameter)
        maxDiameter = diameters[i];
	}
	range = maxDiameter - minDiameter;
	rangePercent = (range / mean) * 100;

    // ---- スコア計算 ----
    cvScore = 100 - cv * 3;
    if (cvScore < 0) cvScore = 0;

    expScore = 100 * exp(-sd / mean);

    adjacentScore = 100 / (1 + meanAdjacentChange / 10);

    residualScore = 100 - residualCV * 5;
    if (residualScore < 0) residualScore = 0;

    reversalPenalty = reversalCount * 10 + maxReversalMagnitude * 2;
    reversalScore = 100 - reversalPenalty;
    if (reversalScore < 0) reversalScore = 0;

    rangeScore = 100 - rangePercent * 2;
    if (rangeScore < 0) rangeScore = 0;

    // ---- 総合スコア ----
    compositeScore = (
        cvScore * 0.20 +
        expScore * 0.15 +
        adjacentScore * 0.20 +
        residualScore * 0.20 +
        reversalScore * 0.15 +
        rangeScore * 0.10
    );
    // 範囲制限
    if (compositeScore < 0) compositeScore = 0;
    if (compositeScore > 100) compositeScore = 100;
    // ---- 出力 ----
    print("==== 安定性解析 ====");
    print("平均径: " + d2s(mean,2) + " μm");
    print("SD: " + d2s(sd,2) + " μm");
    print("CV: " + d2s(cv,2) + " %");
    print("隣接変化率: " + d2s(meanAdjacentChange,2) + " %");
    print("逆行性変化: " + reversalCount + " 箇所");
    print("最大逆行率: " + d2s(maxReversalMagnitude,2) + " %");
    print("傾き: " + d2s(slope,3) + " μm/bin");
    print("残差CV: " + d2s(residualCV,2) + " %");
    print("範囲: " + d2s(rangePercent,2) + " %");
    print("総合スコア: " + d2s(compositeScore,1) + " 点");
    print("");

    return compositeScore;
}

// ========================================
// 領域別血管パラメータ計算
// ========================================
function calculateRegionalVascularParameters(skeletonImageName, roi_index, regionName) {
    print("Calculating parameters for " + regionName + "...");
    
    // デフォルト値
    vesselDensity = 0;
    branchDensity = 0;
    junctionDensity = 0;
    meanDiameter = 0;
    
    if (!selectWindowSafely(skeletonImageName)) {
        return newArray(vesselDensity, branchDensity, junctionDensity, meanDiameter);
    }
    
    // ROI選択
    roiManager("Select", roi_index);
    getStatistics(roiArea, roiMean);
    
    if (roiArea == 0) {
        print("Warning: " + regionName + " ROI has zero area");
        return newArray(vesselDensity, branchDensity, junctionDensity, meanDiameter);
    }
    
    // 血管密度（白ピクセルの割合）
    vesselDensity = roiMean / 255;
    
    // 一時的なスケルトン画像を作成（ROI外を削除）
    selectWindow(skeletonImageName);
    run("Duplicate...", "title=temp_skeleton");
    roiManager("Select", roi_index);
    run("Clear Outside");
    
    // Analyze Skeletonを実行
    run("Analyze Skeleton (2D/3D)", "prune=none show display");
    
    // 結果を取得
    if (nResults > 0) {
        totalBranches = 0;
        totalJunctions = 0;
        totalLength = 0;
        
        for (i = 0; i < nResults; i++) {
            totalBranches += getResult("# Branches", i);
            totalJunctions += getResult("# Junctions", i);
        }
        
        // 密度計算（単位面積あたり）
        branchDensity = totalBranches / roiArea;
        junctionDensity = totalJunctions / roiArea;
        
        print("  " + regionName + ": Branches=" + totalBranches + 
              ", Junctions=" + totalJunctions + ", Area=" + d2s(roiArea, 3));
    }
    
    // Branch information から平均血管径を計算
    if (isOpen("Branch information")) {
        selectWindow("Branch information");
        // この部分は既存のvessel_diameters計算を参考に実装
        // 簡易版として、distance mapから取得
        if (selectWindowSafely("distance")) {
            selectWindow("distance");
            roiManager("Select", roi_index);
            getStatistics(area, mean);
            meanDiameter = mean * 2 * mm_per_pixcel * 1000; // μm
        }
    }
    
    // クリーンアップ
    if (isOpen("temp_skeleton")) {
        selectWindow("temp_skeleton");
        close();
    }
    if (isOpen("Tagged skeleton")) {
        selectWindow("Tagged skeleton");
        close();
    }
    run("Clear Results");
    closeResultsWindow();
    return newArray(vesselDensity, branchDensity, junctionDensity, meanDiameter);
}


// ========================================
// サブタイプ分類のデフォルト値設定
// ========================================
function setDefaultSubtypeValues() {
    vessel_density_center[index] = 0;
    vessel_density_periphery[index] = 0;
    vessel_density_ratio[index] = 1.0;
    branch_density_center[index] = 0;
    branch_density_periphery[index] = 0;
    branch_density_ratio[index] = 1.0;
    junction_density_center[index] = 0;
    junction_density_periphery[index] = 0;
    mean_diameter_center[index] = 0;
    mean_diameter_periphery[index] = 0;
    mnv_subtype[index] = "Unknown";
    subtype_confidence[index] = 0;
}

// ========================================
// 空間分布のデフォルト値設定
// ========================================
function setDefaultSpatialValues() {
    diameter_center_mean[index] = 0;
    diameter_periphery_mean[index] = 0;
    diameter_center_periphery_ratio[index] = 1.0;
    diameter_radial_gradient[index] = 0;
    thick_vessel_center_ratio[index] = 0;
    thick_vessel_periphery_ratio[index] = 0;
}

// ========================================
// 配列を文字列に変換
// ========================================
function arrayToString(arr) {
    str = "[";
    for (i = 0; i < arr.length; i++) {
        str += d2s(arr[i], 1);
        if (i < arr.length - 1) str += ", ";
    }
    str += "]";
    return str;
}

// ========================================
// デフォルト値設定
// ========================================
function setDefaultArteriolarizationValues() {
    arteriolarization_segment_count[index] = 0;
    arteriolarization_total_length[index] = 0;
    arteriolarization_max_segment_length[index] = 0;
    arteriolarization_density[index] = 0;
    arteriolarization_connectivity_index[index] = 0;
    localized_diameter_variation[index] = 0;
    
    // 空間分布のデフォルト値も設定
    setDefaultSpatialValues();
    
    // サブタイプ分類のデフォルト値も設定
    setDefaultSubtypeValues();
}

// ========================================
// 空間分布＋サブタイプ情報追加
// ========================================
function visualizeArteriolarizationSegments(outputDir, file) {
    
    if (!selectWindowSafely("Visualization_RGB")) {
        print("Warning: Visualization_RGB not available");
        return false;
    }
    
    // テキスト追加
    setFont("SanSerif", 11, "bold");
    setColor(255, 255, 0);
    yPos = 15;
    
    // 基本統計
    drawString("Dilated segment Length: " + d2s(arteriolarization_total_length[index], 2) + " mm", 14, yPos);
    yPos += 14;
        
    // サブタイプ情報
    setColor(255, 128, 255); // マゼンタ
    drawString("--- Subtype ---", 14, yPos);
    yPos += 14;
    drawString(mnv_subtype[index], 14, yPos);
        
    if (DEBUG) print("視覚化完了");
    return true;
}

function aggregateBranchInfoByRegion(centerROI_index, peripheryROI_index) {
    DEBUG = false; // デバッグモード

 	if (DEBUG)    print("=== Aggregating Branch Information by Region (with Boundary Branch Removal) ===");

    // ========================================
    // スケール管理
    // ========================================
    if (selectWindowSafely("newskeleton1")) {
        selectWindow("newskeleton1");
        getPixelSize(unit, pixelWidth, pixelHeight);
        if (DEBUG) print("Current scale: " + pixelWidth + " " + unit + "/pixel");

        if (unit != "mm" || pixelWidth != mm_per_pixcel) {
            run("Set Scale...", "distance=1 known=" + mm_per_pixcel + " unit=mm");
            if (DEBUG) print("Scale restored to: " + mm_per_pixcel + " mm/pixel");
        } else if (DEBUG) print("Scale already in mm units");

        w = getWidth();
        h = getHeight();
        if (DEBUG) print("Image size: " + w + "x" + h + " pixels");
    } else {
        print("Error: newskeleton1 not available");
        setDefaultRegionalBranchValues();
        return false;
    }

    // ========================================
    // ステップ1：境界枝用マスク作成
    // ========================================
    selectWindow("newskeleton1");
    run("Duplicate...", "title=skeleton_working");

    newImage("CombinedROI", "8-bit black", w, h, 1);
    roiManager("Select", centerROI_index);
    setColor(255, 255, 255);
    fill();
    roiManager("Select", peripheryROI_index);
    setColor(255, 255, 255);
    fill();
    run("Select None");

    // ========================================
    // ステップ2：中心マスク
    // ========================================
    newImage("CenterMask", "8-bit black", w, h, 1);
    selectWindow("CenterMask");
    roiManager("Select", centerROI_index);
    setColor(255);
    run("Fill");
    run("Select None");

    centerMaskArray = newArray(w * h);
    for (y = 0; y < h; y++) {
        for (x = 0; x < w; x++) {
            centerMaskArray[y * w + x] = getPixel(x, y);
        }
    }
    if (DEBUG) print("Center mask loaded into array");

    // ========================================
    // ステップ3：周辺マスク
    // ========================================
    newImage("PeripheryMask", "8-bit black", w, h, 1);
    selectWindow("PeripheryMask");
    roiManager("Select", peripheryROI_index);
    setColor(255);
    run("Fill");
    run("Select None");

    peripheryMaskArray = newArray(w * h);
    for (y = 0; y < h; y++) {
        for (x = 0; x < w; x++) {
            peripheryMaskArray[y * w + x] = getPixel(x, y);
        }
    }
    if (DEBUG) print("Periphery mask loaded into array");

    // ========================================
    // ステップ4：Branch集計（boundary除外含む）
    // ========================================
	
	selectWindowSafely("skeleton_working");
	run("Set Scale...", "distance=0");
    run("Analyze Skeleton (2D/3D)", "prune=none show display");
    if (isOpen("Branch information")) {
    selectWindow("Branch information");
    Table.rename("Branch information", "Results");
    if (DEBUG) print("Branch information table renamed to Results");
	} else {
    print("Error: Branch information window not open");
    setDefaultRegionalBranchValues();
    return false;
	}

    center_totalLength = 0.0;
    center_only_branchCount = 0;
    center_sumWeightedTortuosity = 0.0;

    periphery_totalLength = 0.0;
    periphery_only_branchCount = 0;
    periphery_sumWeightedTortuosity = 0.0;

    both_branchCount = 0;
    outside_branchCount = 0;

    threshold = skeleton_diameter[index] / 1000.0;
    if (threshold <= 0) threshold = 0.001;

    nBranches = nResults;

    for (i = 0; i < nBranches; i++) {
        v1_x = getResult("V1 x", i);
        v1_y = getResult("V1 y", i);
        v2_x = getResult("V2 x", i);
        v2_y = getResult("V2 y", i);
        branchLength = getResult("Branch length", i);
        euclideanDist = getResult("Euclidean distance", i);

        mid_x = round((v1_x + v2_x)/2.0);
        mid_y = round((v1_y + v2_y)/2.0);

        // 安全化
        if (mid_x < 0) mid_x = 0;
        if (mid_x >= w) mid_x = w - 1;
        if (mid_y < 0) mid_y = 0;
        if (mid_y >= h) mid_y = h - 1;

        // Tortuosity計算
        tortuosity = 1.0;
        if (euclideanDist > threshold && euclideanDist > 0) {
            t = branchLength / euclideanDist;
            if (t >= 1.0) {
                if (t < 10.0) {
                    tortuosity = t;
                }
            }
        }

        pixelIndex = mid_y * w + mid_x;
        centerValue = centerMaskArray[pixelIndex];
        peripheryValue = peripheryMaskArray[pixelIndex];

        // DEBUGログ
        if (DEBUG) print("Branch " + i + ": mid=(" + mid_x + "," + mid_y + "), center=" + centerValue + ", periphery=" + peripheryValue);

        // 分類と集計
        if (centerValue > 128 && peripheryValue > 128) {
            both_branchCount++;
            if (DEBUG) print("  -> Boundary branch excluded");
            // 統計には含めない
        } else if (centerValue > 128) {
            center_totalLength += branchLength;
            center_only_branchCount++;
            center_sumWeightedTortuosity += branchLength * tortuosity;
        } else if (peripheryValue > 128) {
            periphery_totalLength += branchLength;
            periphery_only_branchCount++;
            periphery_sumWeightedTortuosity += branchLength * tortuosity;
        } else {
            outside_branchCount++;
        }
    }

	center_branch [index] = center_only_branchCount;
	periphery_branch [index] = periphery_only_branchCount;
    if (DEBUG) {
        print("Branch classification complete:");
        print("  Center only: " + center_only_branchCount + ", total length=" + center_totalLength);
        print("  Periphery only: " + periphery_only_branchCount + ", total length=" + periphery_totalLength);
        print("  Boundary: " + both_branchCount);
        print("  Outside: " + outside_branchCount);
    }

	// ========================================
	// Skeleton画像の取得
	// ========================================
	if (isOpen("Cleaned_Skeleton")) {
	    selectWindow("Cleaned_Skeleton");
	    skeletonSource = "Cleaned_Skeleton";
	} else if (isOpen("newskeleton1")) {
	    selectWindow("newskeleton1");
	    skeletonSource = "newskeleton1";
	} else {
	    print("Error: No skeleton image available for FD/Euler analysis");
	    setDefaultRegionalBranchValues();
	    return false;
	}

	// ========================================
	// 中心部のskeleton画像を作成
	// ========================================
	run("Duplicate...", "title=Center_Skeleton_Temp");
	newImage("CenterMask_Temp", "8-bit black", w, h, 1);
	roiManager("Select", centerROI_index);
	setColor(255, 255, 255);
	fill();
	run("Select None");
	imageCalculator("AND", "Center_Skeleton_Temp", "CenterMask_Temp");
	rename("Center_Skeleton_Masked");
	if (isOpen("CenterMask_Temp")) {
	    selectWindow("CenterMask_Temp");
	    close();
	}
	if (isOpen("Center_Skeleton_Temp")) {
	    selectWindow("Center_Skeleton_Temp");
	    close();
	}
	
	// 中心部のFD計算
	selectWindow("Center_Skeleton_Masked");
	FD_center[index] = calculateFractalDimensionBoxCounting();
	if (DEBUG) print("Center FD (Box-Counting): " + d2s(FD_center[index], 4));
	
	// ========================================
	// 周辺部のskeleton画像を作成
	// ========================================
	selectWindow(skeletonSource);
	run("Duplicate...", "title=Periphery_Skeleton_Temp");
	newImage("PeripheryMask_Temp", "8-bit black", w, h, 1);
	roiManager("Select", peripheryROI_index);
	setColor(255, 255, 255);
	fill();
	run("Select None");
	imageCalculator("AND", "Periphery_Skeleton_Temp", "PeripheryMask_Temp");
	rename("Periphery_Skeleton_Masked");
	if (isOpen("PeripheryMask_Temp")) {
	    selectWindow("PeripheryMask_Temp");
	    close();
	}
	if (isOpen("Periphery_Skeleton_Temp")) {
	    selectWindow("Periphery_Skeleton_Temp");
	    close();
	}
	
	// 周辺部のFD計算
	selectWindow("Periphery_Skeleton_Masked");
	FD_periphery[index] = calculateFractalDimensionBoxCounting();
	if (DEBUG) print("Periphery FD (Box-Counting): " + d2s(FD_periphery[index], 4));
	
	// ========================================
	// オイラー数の計算
	// ========================================
	
	// 中心部のオイラー数
	selectWindow("Center_Skeleton_Masked");
	resultArray = calculateEulerNumber();
	euler_center[index] = resultArray[0];
	loop_center[index] = resultArray[1];
	if (DEBUG) print("Center Euler Number: " + euler_center[index]);
	
	// 周辺部のオイラー数
	selectWindow("Periphery_Skeleton_Masked");
	resultArray = calculateEulerNumber();
	euler_periphery[index] = resultArray[0];
	loop_periphery[index] = resultArray[1];
	if (DEBUG) print("Periphery Euler Number: " + euler_periphery[index]);
	
	// 最後に一括でクリーンアップ
	close("Center_Skeleton_Masked");
	close("Periphery_Skeleton_Masked");
   
    // ========================================
    // ステップ7：その他の結果を計算して保存
    // ========================================
    
    // mm単位に変換
    vessel_length_center[index] = center_totalLength * mm_per_pixcel;
    vessel_length_periphery[index] = periphery_totalLength * mm_per_pixcel;
    
    // Tortuosityの加重平均
    if (center_totalLength > 0) {
        tortuosity_center[index] = center_sumWeightedTortuosity / center_totalLength;
    } else {
        tortuosity_center[index] = 0;
    }
    
    if (periphery_totalLength > 0) {
        tortuosity_periphery[index] = periphery_sumWeightedTortuosity / periphery_totalLength;
    } else {
        tortuosity_periphery[index] = 0;
    }
    
    // 結果サマリー
    if (DEBUG) print("=== Regional Branch Analysis Results (with Boundary Branch Removal) ===");
    if (DEBUG) print("Center:");
    if (DEBUG) print("  Branches: " + center_only_branchCount);
    if (DEBUG) print("  Total length: " + d2s(vessel_length_center[index], 3) + " mm");
    if (DEBUG) print("  Tortuosity: " + d2s(tortuosity_center[index], 3));
    if (DEBUG) print("  FD (Box-Counting): " + d2s(FD_center[index], 4));
    if (DEBUG) print("  Euler Number: " + euler_center[index]);
    if (DEBUG) print("  Loop Number: " + loop_center[index]);
    
    if (DEBUG) print("Periphery:");
    if (DEBUG) print("  Branches: " + periphery_only_branchCount);
    if (DEBUG) print("  Total length: " + d2s(vessel_length_periphery[index], 3) + " mm");
    if (DEBUG) print("  Tortuosity: " + d2s(tortuosity_periphery[index], 3));
    if (DEBUG) print("  FD (Box-Counting): " + d2s(FD_periphery[index], 4));
    if (DEBUG) print("  Euler Number: " + euler_periphery[index]);
    if (DEBUG) print("  Loop Number: " + loop_periphery[index]);
 
    // メモリ解放
    centerMaskArray = 0;
    peripheryMaskArray = 0;

    if (DEBUG) print("=== Branch Information Aggregation Complete ===");
    return true;
}

// ========================================
// Box-Counting法によるフラクタル次元計算
// ========================================
function calculateFractalDimensionBoxCounting() {
    // 現在選択されている二値画像に対してBox-Countingを実行
    
    imgID = getImageID();
    imgWidth = getWidth();
    imgHeight = getHeight();
    
    // 複数のボックスサイズを設定（2の累乗）
    minBoxSize = 2;
    maxBoxSize = 128;
    
    // 画像サイズに応じてmaxBoxSizeを調整
    maxDim = maxOf(imgWidth, imgHeight);
    if (maxBoxSize > maxDim / 4) {
        maxBoxSize = pow(2, floor(log(maxDim / 4) / log(2)));
    }
    
    boxSizes = newArray();
    boxCounts = newArray();
    
    if (DEBUG) print("  Box-Counting analysis:");
    
    // 各ボックスサイズでカウント
    for (boxSize = minBoxSize; boxSize <= maxBoxSize; boxSize *= 2) {
        count = countBoxesContainingSkeleton(boxSize, imgWidth, imgHeight);
        
        if (count > 0) {
            boxSizes = Array.concat(boxSizes, boxSize);
            boxCounts = Array.concat(boxCounts, count);
            if (DEBUG) print("    Box size " + boxSize + ": " + count + " boxes");
        }
    }
    
    // 最小二乗法でフラクタル次元を計算
    if (boxSizes.length < 3) {
        print("  Warning: Insufficient data points for FD calculation");
        return 0;
    }
    
    // log-logプロットの傾きを計算
    n = boxSizes.length;
    sumLogS = 0;
    sumLogN = 0;
    sumLogSLogN = 0;
    sumLogS2 = 0;
    
    for (i = 0; i < n; i++) {
        logS = log(1.0 / boxSizes[i]);  // log(1/box size)
        logN = log(boxCounts[i]);        // log(box count)
        
        sumLogS += logS;
        sumLogN += logN;
        sumLogSLogN += logS * logN;
        sumLogS2 += logS * logS;
    }
    
    // 傾き = FD
    slope = (n * sumLogSLogN - sumLogS * sumLogN) / (n * sumLogS2 - sumLogS * sumLogS);
    
    // R²値を計算（フィッティングの質）
    meanLogN = sumLogN / n;
    ssTotal = 0;
    ssResidual = 0;
    
    for (i = 0; i < n; i++) {
        logS = log(1.0 / boxSizes[i]);
        logN = log(boxCounts[i]);
        predicted = slope * logS + (meanLogN - slope * sumLogS / n);
        
        ssTotal += pow(logN - meanLogN, 2);
        ssResidual += pow(logN - predicted, 2);
    }
    
    r2 = 1 - (ssResidual / ssTotal);
    if (DEBUG) print("    R² = " + d2s(r2, 4));
    
    // 妥当性チェック
    if (slope < 0.5 || slope > 2.5) {
        print("  Warning: FD out of expected range (" + d2s(slope, 4) + ")");
        return 0;
    }
    
    if (r2 < 0.9) {
        print("  Warning: Poor fit quality (R² = " + d2s(r2, 4) + ")");
    }
    
    return slope;
}

// ========================================
// 指定サイズのボックスでskeletonを含むボックスをカウント
// ========================================
function countBoxesContainingSkeleton(boxSize, imgWidth, imgHeight) {
    count = 0;
    
    // グリッドを走査
    for (y = 0; y < imgHeight; y += boxSize) {
        for (x = 0; x < imgWidth; x += boxSize) {
            // このボックス内にskeletonピクセルがあるかチェック
            hasSkeleton = false;
            
            for (dy = 0; dy < boxSize && (y + dy) < imgHeight; dy++) {
                for (dx = 0; dx < boxSize && (x + dx) < imgWidth; dx++) {
                    pixelValue = getPixel(x + dx, y + dy);
                    if (pixelValue > 0) {
                        hasSkeleton = true;
                        break;
                    }
                }
                if (hasSkeleton) break;
            }
            
            if (hasSkeleton) {
                count++;
            }
        }
    }
    
    return count;
}

// ========================================
// オイラー数の計算（8連結）
// ========================================
function calculateEulerNumber() {
    // 現在選択されている二値画像のオイラー数を計算
    // Euler Number = (連結成分数) - (ループ数)
    // 負の値 = メッシュ状構造が多い
    
    imgWidth = getWidth();
    imgHeight = getHeight();
    
   if (DEBUG)     print("  Calculating Euler Number...");
    
    // Analyze Particlesで連結成分数を取得
    run("Set Measurements...", "area mean redirect=None decimal=3");
    run("Analyze Particles...", "size=0-Infinity show=Nothing display clear");
    nComponents = nResults;
    
    if (nComponents == 0) {
        print("    No connected components found");
        return 0;
    }
    
    if (DEBUG) print("    Connected components: " + nComponents);
    
    // ループ数の計算（skeletonから分岐点と端点を解析）
    // Analyze Skeletonの結果を利用
    run("Analyze Skeleton (2D/3D)", "prune=none show");
    
	// Results tableから値を取得（全行を集計）
	nBranches = 0;
	nJunctions = 0;
	nEndpoints = 0;
	
	if (nResults > 0) {
	    for (i = 0; i < nResults; i++) {
	        // 各行の値を加算
	        nBranches += getResult("# Branches", i);
	        nJunctions += getResult("# Junctions", i);
	        nEndpoints += getResult("# End-point voxels", i);
	    }
	}
	
	if (DEBUG) print("    Branches: " + nBranches);
	if (DEBUG) print("    Junctions: " + nJunctions);
	if (DEBUG) print("    Endpoints: " + nEndpoints);
	    
    // オイラー数の計算
    // Euler = V - E + F (頂点 - 辺 + 面)
    // 2Dスケルトンの場合: Euler = (端点数 + 分岐点数) - (枝数)
    // または簡易的に: Euler = 連結成分数 - ループ数
    
    // グラフ理論に基づく計算
    V = nEndpoints + nJunctions;  // 頂点数
    E = nBranches;                 // 辺数
    
    // Euler's formula for planar graphs: V - E + F = 2
    // F = 2 - V + E (面数、外側を含む)
    // ループ数 = F - 1 (外側の面を除く)
    nLoops = E - V + nComponents;
    
    eulerNumber = nComponents - nLoops;
    
   if (DEBUG)     print("    Loops detected: " + nLoops);
   if (DEBUG)     print("    Euler Number: " + eulerNumber);
    
    // 結果テーブルをクリーンアップ
    if (isOpen("Results")) {
        selectWindow("Results");
        run("Close");
    }
    if (isOpen("Branch information")) {
        selectWindow("Branch information");
        run("Close");
    }
    if (isOpen("Tagged skeleton")) {
        selectWindow("Tagged skeleton");
        close();
    }
    
    return newArray(eulerNumber,nLoops);
}


// ========================================
// デフォルト値設定
// ========================================
function setDefaultRegionalBranchValues() {
    FD_center[index] = 0;
    FD_periphery[index] = 0;
    tortuosity_center[index] = 0;
    tortuosity_periphery[index] = 0;
    vessel_length_center[index] = 0;
    vessel_length_periphery[index] = 0;
    euler_center[index] = 0;
    euler_periphery[index] = 0;
}

function classifyMNVbyLoopsDetailed() {
//	print("\\Clear");
    print("=== MNV Pattern Classification (Indicator-Based) ===");

    // === 実測値取得 ===
    branchDensityCenter    = center_branch[index] / vessel_length_center[index];
    branchDensityPeriphery = periphery_branch[index] / vessel_length_periphery[index];
    loopCenterDensity      = loop_center[index] / vessel_length_center[index];
    loopPeripheryDensity   = loop_periphery[index] / vessel_length_periphery[index];
    loopsCenter            = loop_center[index];
    loopsPeriphery         = loop_periphery[index];
    eulerCenterVal         = euler_center[index];
    eulerPeripheryVal      = euler_periphery[index];
    compositeScore         = stability_score[index];
    trunkEccentricity      = trunk_eccentricity[index];
    angularCV              = angular_distribution_cv[index];

    // === Vascular Complexity Score計算 ===
    complexityScore = calculateComplexityScore(index);
    
    // グローバル変数に保存
    complexity_score[index] = complexityScore;
    maturity_index[index] = 50 + (stability_score[index] - complexity_score[index])/2;

    // === 血管複雑性指標（Vascular Complexity）===
    print("");
    print("=== Composite Vascular Complexity Score ===");
    print("Complexity Score: " + d2s(complexityScore, 1) + " / 100");
    if (complexityScore >= 80) {
        print("  → Very High Complexity (Medusa-like)");
    } else if (complexityScore >= 65) {
        print("  → High Complexity (Seafan/Glomerular-like)");
    } else if (complexityScore >= 50) {
        print("  → Moderate Complexity (Tree in bud-like)");
    } else {
        print("  → Low Complexity (Dead tree-like)");
    }
    
    // === 詳細指標（参考）===
    if (DEBUG) print("");
    if (DEBUG) print("=== Detailed Vascular Indicators (for reference) ===");
    if (DEBUG) print("Branch Density Center: " + d2s(branchDensityCenter, 2) + " branches/mm");
    if (DEBUG) print("Branch Density Periphery: " + d2s(branchDensityPeriphery, 2) + " branches/mm");
    if (DEBUG) print("Loop Density Center: " + d2s(loopCenterDensity, 2) + " loops/mm");
    if (DEBUG) print("Loop Density Periphery: " + d2s(loopPeripheryDensity, 2) + " loops/mm");
    if (DEBUG) print("Total Loops: " + (loopsCenter + loopsPeriphery));
    if (DEBUG) print("Euler Number (Center/Periphery): " + eulerCenterVal + " / " + eulerPeripheryVal);
    
    // Center/Periphery比
    cp_loop_ratio = loopCenterDensity / (loopPeripheryDensity + 0.0001);
    cp_branch_ratio = branchDensityCenter / (branchDensityPeriphery + 0.0001);
    if (DEBUG) print("Center/Periphery Loop Ratio: " + d2s(cp_loop_ratio, 3));
    if (DEBUG) print("Center/Periphery Branch Ratio: " + d2s(cp_branch_ratio, 3));

    // === 血管安定性指標（Vascular Stability）===
    print("");
    print("=== Vessel Diameter Stability Score ===");
    print("Stability Score: " + d2s(compositeScore, 1) + " / 100");
    if (compositeScore > 85) {
        print("  → High Stability (Dead tree-like)");
    } else if (compositeScore > 75) {
        print("  → Moderate Stability");
    } else {
        print("  → Low Stability (Active/Immature pattern)");
    }

    // === 血管構造配置（Trunk vessel distribution）===
    if (DEBUG) print("");
    if (DEBUG) print("=== Trunk Vessel Spatial Distribution ===");
    if (DEBUG) print("Trunk Eccentricity: " + d2s(trunkEccentricity, 3));
    if (DEBUG) print("  (0=Central radial, 1=Peripheral eccentric)");
    if (DEBUG) print("Angular Distribution CV: " + d2s(angularCV, 3));
    if (DEBUG) print("  (Low=Uniform all directions, High=Directional/unilateral)");
    
    // 血管径の中心/末梢比
    if (diameter_center_periphery_ratio[index] > 0) {
        print("Diameter Center/Periphery Ratio: " + d2s(diameter_center_periphery_ratio[index], 3));
    }

    // === パターン判定 ===
	suggestedPattern = patternClassification;
	print("=== Trunk Vessel Pattern ===");
   	print("Classification: " + patternClassification + " (Score: " + d2s(totalScore, 1) + ", Confidence: " + confidence + ")");
     

	// === Final 5-pattern classification based on complexity & compositeScore ===
	// patternClassification (MEDUSA / INTERMEDIATE / SEAFAN) is used instead of cp_loop_ratio
	// Dialog and confidence recalculation included
	
	
	// --- Suggested pattern determination ---
	if (complexityScore < 40 && compositeScore > 85) {
	print("→ DEAD TREE (Low complexity + High stability)");
	suggestedPattern = "Dead tree";
	} else if (complexityScore >= 40 && complexityScore < 65) {
	print("→ TREE IN BUD (Moderate complexity)");
	suggestedPattern = "Tree in bud";
	} else if (complexityScore >= 55 && patternClassification == "SEAFAN") {
	print("→ SEAFAN (High complexity + Eccentric pattern)");
	suggestedPattern = "Seafan";
	} else if (complexityScore >= 75 && patternClassification == "MEDUSA") {
	print("→ MEDUSA (Very high complexity + Central pattern)");
	suggestedPattern = "Medusa";
	} else if (complexityScore >= 65) {
	print("→ GLOMERULAR (High complexity + Balanced)");
	suggestedPattern = "Glomerular";
	} else if (patternClassification == "INTERMEDIATE") {
	print("→ TREE IN BUD (Intermediate tendency)");
	suggestedPattern = "Tree in bud";
	} else {
	print("→ TREE IN BUD (Default for moderate patterns)");
	suggestedPattern = "Tree in bud";
	}
	
	
	print("");	
	

	// === Dialog表示 ===
	pattern_names = newArray("Dead tree", "Tree in bud", "Glomerular", "Seafan", "Medusa");
	Dialog.create("MNV Pattern Classification");
	Dialog.addMessage("Complexity: " + d2s(complexityScore, 1) + " / Stability: " + d2s(compositeScore, 1));
	Dialog.addMessage("Suggested: " + suggestedPattern);
	Dialog.addChoice("Select pattern:", pattern_names, suggestedPattern);
	Dialog.show();
	
	
	selected = Dialog.getChoice();
	print("User selected: " + selected);
	mnv_subtype[index] = selected;
	
	
	// === Confidence calculation ===
	confidence = 0.5; // default
	
	
	if (selected == "Dead tree") {
	if (complexityScore < 35 && compositeScore > 85) confidence = 0.95;
	else if (complexityScore < 45 && compositeScore > 80) confidence = 0.80;
	else if (complexityScore < 55) confidence = 0.65;
	} else if (selected == "Tree in bud") {
	if (complexityScore >= 40 && complexityScore < 65 && compositeScore < 80) confidence = 0.90;
	else if (complexityScore >= 35 && complexityScore < 70) confidence = 0.75;
	else confidence = 0.60;
	} else if (selected == "Seafan") {
	if (patternClassification == "SEAFAN" && complexityScore >= 55) confidence = 0.95;
	else if (patternClassification == "INTERMEDIATE" && complexityScore >= 50) confidence = 0.80;
	else if (patternClassification == "SEAFAN") confidence = 0.70;
	else confidence = 0.60;
	} else if (selected == "Medusa") {
	if (patternClassification == "MEDUSA" && complexityScore >= 75) confidence = 0.95;
	else if (patternClassification == "MEDUSA" && complexityScore >= 70) confidence = 0.80;
	else if (complexityScore >= 65) confidence = 0.70;
	else confidence = 0.60;
	} else if (selected == "Glomerular") {
	if (complexityScore >= 65 && compositeScore > 70) confidence = 0.90;
	else if (complexityScore >= 60) confidence = 0.75;
	else if (complexityScore >= 55) confidence = 0.65;
	else confidence = 0.55;
	}
	
	
	subtype_confidence[index] = confidence;
	
	
	// === Summary output ===
	print("");
	print("=== Trunk Vessel Pattern ===");
	print("Base Class (3-way): " + patternClassification);
	print("Final Classification: " + selected + " (Score: " + d2s(totalScore,1) + ", Confidence: " + d2s(confidence*100,1) + "% )");
}


function calculateComplexityScore(index) {
    if (DEBUG) print("==== Vascular Complexity Analysis ====");
    
    // === 入力データ取得 ===
    branchDensityCenter = center_branch[index] / vessel_length_center[index];
    branchDensityPeriphery = periphery_branch[index] / vessel_length_periphery[index];
    loopDensityCenter = loop_center[index] / vessel_length_center[index];
    loopDensityPeriphery = loop_periphery[index] / vessel_length_periphery[index];
    loopsCenter = loop_center[index];
    loopsPeriphery = loop_periphery[index];
    eulerCenter = euler_center[index];
    eulerPeriphery = euler_periphery[index];
    
    // Trunk vessel分布データ（既存の配列から取得）
    trunkEcc = trunk_eccentricity[index];
    angularCV = angular_distribution_cv[index];
    thickCenterRatio = thick_vessel_center_ratio[index];
    diameterRatio = diameter_center_periphery_ratio[index];
    
    // Center/Periphery比
    cpLoopRatio = loopDensityCenter / (loopDensityPeriphery + 0.0001);
    cpBranchRatio = branchDensityCenter / (branchDensityPeriphery + 0.0001);
    
    // === 1. Branch Density Score（分岐密度）===
    // 高密度ほど複雑（参考値：5-30 branches/mm）
    avgBranchDensity = (branchDensityCenter + branchDensityPeriphery) / 2;
    branchDensityScore = 100 * (1 - exp(-avgBranchDensity / 15));
    if (branchDensityScore > 100) branchDensityScore = 100;
    
    if (DEBUG) print("Average Branch Density: " + d2s(avgBranchDensity, 2) + " branches/mm");
    if (DEBUG) print("  Branch Density Score: " + d2s(branchDensityScore, 1) + " / 100");
    
    // === 2. Loop Density Score（ループ密度）===
    // 高密度ほど複雑（参考値：0-8 loops/mm）
    avgLoopDensity = (loopDensityCenter + loopDensityPeriphery) / 2;
    loopDensityScore = 100 * (1 - exp(-avgLoopDensity / 4));
    if (loopDensityScore > 100) loopDensityScore = 100;
    
    if (DEBUG) print("Average Loop Density: " + d2s(avgLoopDensity, 2) + " loops/mm");
    if (DEBUG) print("  Loop Density Score: " + d2s(loopDensityScore, 1) + " / 100");
    
    // === 3. Total Loops Score（総ループ数）===
    // 絶対数も重要（参考値：0-200 loops）
    totalLoops = loopsCenter + loopsPeriphery;
    totalLoopsScore = 100 * (1 - exp(-totalLoops / 80));
    if (totalLoopsScore > 100) totalLoopsScore = 100;
    
    if (DEBUG) print("Total Loops: " + totalLoops);
    if (DEBUG) print("  Total Loops Score: " + d2s(totalLoopsScore, 1) + " / 100");
    
    // === 4. Euler Number Score（位相的複雑性）===
    // Euler数が負で絶対値が大きいほど複雑
    avgEuler = (eulerCenter + eulerPeriphery) / 2;
    eulerComplexity = -avgEuler;  // 負→正に変換
    eulerScore = 100 * (1 - exp(-eulerComplexity / 30));
    if (eulerScore < 0) eulerScore = 0;
    if (eulerScore > 100) eulerScore = 100;
    
    if (DEBUG) print("Average Euler Number: " + d2s(avgEuler, 1));
    if (DEBUG) print("  Euler Complexity Score: " + d2s(eulerScore, 1) + " / 100");
    
    // === 5. Spatial Distribution Score（空間分布の均一性）===
    // Center/Peripheryが均等に発達しているほど複雑
    // 理想は比率1.0（完全均等）
    loopRatioDeviation = abs(cpLoopRatio - 1.0);
    branchRatioDeviation = abs(cpBranchRatio - 1.0);
    avgDeviation = (loopRatioDeviation + branchRatioDeviation) / 2;
    
    // 偏りが少ないほど高スコア
    spatialScore = 100 * exp(-avgDeviation * 2);
    
    if (DEBUG) print("Center/Periphery Loop Ratio: " + d2s(cpLoopRatio, 3));
    if (DEBUG) print("Center/Periphery Branch Ratio: " + d2s(cpBranchRatio, 3));
    if (DEBUG) print("  Spatial Distribution Score: " + d2s(spatialScore, 1) + " / 100");
    if (DEBUG) print("  (High score = balanced distribution)");
    
    // === 6. Anastomotic Index（吻合指数）===
    // Loops per branch = 吻合の多さを示す
    totalBranches = center_branch[index] + periphery_branch[index];
    anastomoticIndex = totalLoops / (totalBranches + 1);
    anastomoticScore = 100 * (1 - exp(-anastomoticIndex / 0.3));
    if (anastomoticScore > 100) anastomoticScore = 100;
    
    if (DEBUG) print("Anastomotic Index: " + d2s(anastomoticIndex, 3) + " loops/branch");
    if (DEBUG) print("  Anastomotic Score: " + d2s(anastomoticScore, 1) + " / 100");
    
    // ========================================
    // === 7. Trunk Vessel Distribution Score（新規追加）===
    // ========================================
    // 中心性・全方向性が高いほど高スコア（Medusa型が高複雑性）
    
    trunkDistributionScore = 0;
    
    if (trunkEcc >= 0 && angularCV >= 0) {
        // 有効なデータがある場合
        
        // A. Centrality Score（中心性）
        // Eccentricity が低いほど高スコア（0=中心性100点、1=周辺性0点）
        centralityScore = 100 * (1 - trunkEcc);
        
        // B. Radiality Score（放射状均一性）
        // Angular CVが低いほど高スコア（低CV=全方向均一=高複雑性）
        if (angularCV >= 0) {
            radialityScore = 100 * exp(-angularCV * 2);  // CV=0→100点、CV=1→13点
        } else {
            radialityScore = 50;  // データ不足の場合は中間値
        }
        
        // C. Central Density Bonus（中心部血管密度）
        // 中心部が密なほど高スコア
        centralDensityBonus = 0;
        if (thickCenterRatio > 15) {
            centralDensityBonus = 20;
        } else if (thickCenterRatio > 10) {
            centralDensityBonus = 10;
        }
        
        // D. Diameter Uniformity（径の均一性）
        // 中心と周辺の径が近いほど高スコア
        diameterUniformity = 0;
        if (diameterRatio > 1.0 && diameterRatio < 1.5) {
            diameterUniformity = 100 * (1.5 - diameterRatio) / 0.5;
        } else if (diameterRatio >= 1.5) {
            diameterUniformity = 0;
        } else {
            diameterUniformity = 50;  // 周辺優位の場合
        }
        
        // 統合スコア（重み付き）
        trunkDistributionScore = (
            centralityScore * 0.40 +      // 中心性（40%）
            radialityScore * 0.30 +       // 放射状均一性（30%）
            diameterUniformity * 0.20 +   // 径の均一性（20%）
            centralDensityBonus * 0.10    // 中心密度ボーナス（10%）
        );
        
        if (trunkDistributionScore > 100) trunkDistributionScore = 100;
        if (trunkDistributionScore < 0) trunkDistributionScore = 0;
        
        if (DEBUG) {
            print("--- Trunk Vessel Distribution Analysis ---");
            print("Trunk Eccentricity: " + d2s(trunkEcc, 3) + " (0=central, 1=peripheral)");
            print("  Centrality Score: " + d2s(centralityScore, 1));
            print("Angular CV: " + d2s(angularCV, 3) + " (low=uniform)");
            print("  Radiality Score: " + d2s(radialityScore, 1));
            print("Diameter Ratio (C/P): " + d2s(diameterRatio, 3));
            print("  Diameter Uniformity: " + d2s(diameterUniformity, 1));
            print("Central Vessel Density: " + d2s(thickCenterRatio, 1) + "%");
            print("  Central Density Bonus: " + d2s(centralDensityBonus, 1));
            print("  >> Trunk Distribution Score: " + d2s(trunkDistributionScore, 1) + " / 100");
        }
        
    } else {
        // データ不足の場合は中間値
        trunkDistributionScore = 50;
        if (DEBUG) print("Trunk Distribution Score: N/A (insufficient data, using 50)");
    }
    
    // ========================================
    // === 総合Complexity Score（統合版）===
    // ========================================
    // 重み付き平均（7要素）
    
    complexityScore = (
        totalLoopsScore * 0.30 +         // 総ループ数（30%）← 40%から減少
        eulerScore * 0.30 +              // Euler複雑性（30%）← 40%から減少
        trunkDistributionScore * 0.20 +  // Trunk分布（20%）← 新規追加
        spatialScore * 0.12 +            // 空間分布（12%）← 15%から減少
        anastomoticScore * 0.05 +        // 吻合指数（5%）
        branchDensityScore * 0.03        // 分岐密度（3%）← 新規追加（微量）
    );
    // 範囲制限（重要！）
    if (complexityScore < 0) complexityScore = 0;
    if (complexityScore > 100) complexityScore = 100;    
    // ========================================
    // 補正ロジック（拡張版）
    // ========================================
    
    // 1. 非常に高いループ数 + 低分岐密度 = 非常に高複雑性
    if (totalLoops > 150 && branchDensityScore < 50) {
        complexityScore = Math.max(complexityScore, 80);
    }
    
    // 2. 非常に高いEuler複雑性 = 非常に高複雑性
    if (eulerScore > 85) {
        complexityScore = Math.max(complexityScore, 80);
    }
    
    // 3. Medusa型（中心性+全方向性）+ 高ループ数 = 非常に高複雑性
    if (trunkEcc >= 0 && trunkEcc < 0.3 && totalLoops > 100) {
        if (angularCV >= 0 && angularCV < 0.5) {
            complexityScore = Math.max(complexityScore, 85);
            if (DEBUG) print("  >> Medusa-type high complexity pattern detected");
        }
    }
    
    // 4. Seafan型（偏心性+方向性）でも高ループ = 高複雑性
    if (trunkEcc >= 0 && trunkEcc > 0.6 && totalLoops > 120) {
        complexityScore = Math.max(complexityScore, 75);
        if (DEBUG) print("  >> Seafan-type with high loop density detected");
    }
    
    // 5. 極端に低い複雑性の下限設定
    if (totalLoops < 10 && eulerScore < 20) {
        complexityScore = Math.min(complexityScore, 25);
    }
    
    // 最終範囲チェック
    if (complexityScore > 100) complexityScore = 100;
    if (complexityScore < 0) complexityScore = 0;
    
    // ========================================
    // 複雑性レベルの分類
    // ========================================
    complexityLevel = "";
    if (complexityScore >= 80) {
        complexityLevel = "VERY HIGH";
    } else if (complexityScore >= 60) {
        complexityLevel = "HIGH";
    } else if (complexityScore >= 40) {
        complexityLevel = "MODERATE";
    } else if (complexityScore >= 20) {
        complexityLevel = "LOW";
    } else {
        complexityLevel = "VERY LOW";
    }
    
    if (DEBUG) {
        print("");
        print("==== Final Complexity Assessment ====");
        print("Overall Complexity Score: " + d2s(complexityScore, 1) + " / 100");
        print("Complexity Level: " + complexityLevel);
        print("=====================================");
    }
    
    return complexityScore;
}
///////////////////////////////////////////////////////////////////////////////
// 日時文字列を取得する関数
///////////////////////////////////////////////////////////////////////////////
function getDateTimeString() {
    getDateAndTime(year, month, dayOfWeek, dayOfMonth, hour, minute, second, msec);
    month = month + 1; // 月は0から始まるので+1
    
    monthStr = d2s(month, 0);
    if (month < 10) monthStr = "0" + monthStr;
    
    dayStr = d2s(dayOfMonth, 0);
    if (dayOfMonth < 10) dayStr = "0" + dayStr;
    
    hourStr = d2s(hour, 0);
    if (hour < 10) hourStr = "0" + hourStr;
    
    minStr = d2s(minute, 0);
    if (minute < 10) minStr = "0" + minStr;
    
    secStr = d2s(second, 0);
    if (second < 10) secStr = "0" + secStr;
    
    return d2s(year, 0) + "-" + monthStr + "-" + dayStr + " " + hourStr + ":" + minStr + ":" + secStr;
}

///////////////////////////////////////////////////////////////////////////////
// ログをファイルに保存する関数
///////////////////////////////////////////////////////////////////////////////
function saveLogToFile() {

    
    // Get user signature
    Dialog.create("Put your signature");
    Dialog.addString("Analyst Name (Romaji):", "");
    Dialog.show();
    
    analystName = Dialog.getString();
    print("Analyzed by: " + analystName);

    logContent = getInfo("log");
    
    if (lengthOf(logContent) == 0) {
        print("Warning: No log content to save.");
        return;
    }
    // Check if name was entered
    if (lengthOf(analystName) == 0) {
        print("Warning: No signature provided. Log not saved.");
        return;
    }
    
    logFileName = "ARIAKE_Registration_Log.txt";
 
    logFilePath = s_output + File.separator + logFileName;
    
    // Add header information to log with analyst signature
    logHeader = "=================================================\n";
    logHeader += "ARIAKE OCTA v2.1\n";
    logHeader += "Log File Generated: " + getDateTimeString() + "\n";
    logHeader += "Analyzed by: " + analystName + "\n";
    logHeader += "=================================================\n\n";
    
    fullLog = logHeader + logContent;
    
    File.saveString(fullLog, logFilePath);
    
    print("\n=================================================");
    print("Log file saved successfully");
    print("Analyst: " + analystName);
    print("File: " + logFileName);
    print("Path: " + logFilePath);
    print("=================================================");
    showMessage("Log Saved", "Log file has been saved to:\n" + logFilePath + "\n\nAnalyzed by: " + analystName);
}
///////////////////////////////////////////////////////////////////////////////
// 画像を8bitに変換し、サイズ(ppi)を4倍に拡大する関数
///////////////////////////////////////////////////////////////////////////////
function quadrupleimgsize(){
	run("8-bit");
	imageWidth = getWidth(); 
	imageHight = getHeight();
	run("Size...", "width=" + imageWidth*4 + " height=" + imageHight*4 + " constrain average interpolation=Bicubic");
}